package eu.neverblink.protoc.java.gen

import com.google.protobuf.compiler.PluginProtos
import com.google.protobuf.compiler.PluginProtos.{CodeGeneratorRequest, CodeGeneratorResponse}
import com.palantir.javapoet.{JavaFile, TypeSpec}

import java.io.{IOException, InputStream}
import java.util
import javax.lang.model.element.Modifier
import scala.collection.mutable.ListBuffer
import scala.jdk.CollectionConverters.*

/**
 * Protoc plugin that gets called by the protoc executable. The communication happens
 * via protobuf messages on System.in / System.out
 *
 * @author Florian Enner
 * @since 05 Aug 2019
 */
object FastJavaPlugin:
  /**
   * The protoc-gen-plugin communicates via proto messages on System.in and System.out
   *
   * @param args
   * @throws IOException
   */
  @throws[IOException]
  def main(args: Array[String]): Unit = {
    if (args.length > 0) {
      System.out.println("This protobuf plugin should be called by protoc. Example:\n\n" +
        "    1) protoc --plugin=protoc-gen-quickbuf=${executable} --quickbuf_out=store_unknown_fields=true:. type.proto\n" +
        "    2) protoc --quickbuf_out=store_unknown_fields=true:. type.proto\n\n" +
        "Note that if you are calling this plugin from the PATH (2), the executable\n" +
        "file or wrapper script needs to be called \"protoc-gen-quickbuf\"."
      )
      return
    }
    handleRequest(System.in).writeTo(System.out)
  }

  @throws[IOException]
  def handleRequest(input: InputStream): CodeGeneratorResponse =
    try handleRequest(CodeGeneratorRequest.parseFrom(input))
    catch {
      case ex: Exception =>
        ParserUtil.asErrorWithStackTrace(ex)
    }

  def handleRequest(requestProto: PluginProtos.CodeGeneratorRequest): CodeGeneratorResponse =
    val response = CodeGeneratorResponse.newBuilder
    val request = RequestInfo.withTypeRegistry(requestProto)
    // Signal support for proto3 optionals. They behave the same as proto2
    // optionals, so that feature is actually supported.
    response.setSupportedFeatures(CodeGeneratorResponse.Feature.FEATURE_PROTO3_OPTIONAL_VALUE)
    val filesToGenerate = new util.HashSet[String](requestProto.getFileToGenerateList)
    for (
      // Only generate files that were specifically selected (see issue #62)
      file <- request.files.asScala if filesToGenerate.contains(file.fileName)
    ) {
      // Generate type specifications
      val topLevelTypes = new ListBuffer[TypeSpec]
      val outerClassSpec = TypeSpec.classBuilder(file.outerClassName).addModifiers(Modifier.PUBLIC, Modifier.FINAL)
      val list: TypeSpec => Unit = if (file.generateMultipleFiles) topLevelTypes.addOne
      else outerClassSpec.addType
      for (t <- file.enumTypes.asScala) {
        list(new EnumGenerator(t).generate)
      }
      for (t <- file.messageTypes.asScala) {
        list(new MessageGenerator(t).generate)
      }
      if (file.generateDescriptors) new DescriptorGenerator(file).generate(outerClassSpec)
      // Omitt completely empty outer classes
      if (file.generateDescriptors || !file.generateMultipleFiles)
        topLevelTypes.append(outerClassSpec.build)
      // Generate Java files
      for (typeSpec <- topLevelTypes) {
        val javaFile = JavaFile.builder(file.javaPackage, typeSpec)
          .addFileComment("Code generated by protocol buffer compiler. Do not edit!")
          .indent(request.pluginOptions.indentString).skipJavaLangImports(true)
          .build
        val content = new java.lang.StringBuilder(1000)
        try javaFile.writeTo(content)
        catch {
          case e: IOException =>
            throw new AssertionError("Could not write to StringBuilder?")
        }
        response.addFile(CodeGeneratorResponse.File.newBuilder
          .setName(file.outputDirectory + typeSpec.name + ".java")
          .setContent(content.toString)
          .build
        )
      }
    }
    response.build

