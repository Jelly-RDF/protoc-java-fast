// Code generated by protocol buffer compiler. Do not edit!
package eu.ostrzyciel.jelly.core.proto.v1;

import com.google.protobuf.ByteString;
import com.google.protobuf.CodedInputStream;
import com.google.protobuf.CodedOutputStream;
import com.google.protobuf.InvalidProtocolBufferException;
import eu.neverblink.protoc.java.runtime.MessageFactory;
import eu.neverblink.protoc.java.runtime.ProtoEnum;
import eu.neverblink.protoc.java.runtime.ProtoMessage;
import eu.neverblink.protoc.java.runtime.RepeatedMessage;
import java.io.IOException;
import java.util.Collections;
import java.util.List;

public final class Rdf {
  /**
   * Protobuf enum {@code PhysicalStreamType}
   */
  public enum PhysicalStreamType implements ProtoEnum<PhysicalStreamType> {
    /**
     * <code>UNSPECIFIED = 0;</code>
     */
    UNSPECIFIED("UNSPECIFIED", 0),

    /**
     * <code>TRIPLES = 1;</code>
     */
    TRIPLES("TRIPLES", 1),

    /**
     * <code>QUADS = 2;</code>
     */
    QUADS("QUADS", 2),

    /**
     * <code>GRAPHS = 3;</code>
     */
    GRAPHS("GRAPHS", 3);

    /**
     * <code>UNSPECIFIED = 0;</code>
     */
    public static final int UNSPECIFIED_VALUE = 0;

    /**
     * <code>TRIPLES = 1;</code>
     */
    public static final int TRIPLES_VALUE = 1;

    /**
     * <code>QUADS = 2;</code>
     */
    public static final int QUADS_VALUE = 2;

    /**
     * <code>GRAPHS = 3;</code>
     */
    public static final int GRAPHS_VALUE = 3;

    private final String name;

    private final int number;

    private PhysicalStreamType(String name, int number) {
      this.name = name;
      this.number = number;
    }

    /**
     * @return the string representation of enum entry
     */
    @Override
    public String getName() {
      return name;
    }

    /**
     * @return the numeric wire value of this enum entry
     */
    @Override
    public int getNumber() {
      return number;
    }

    /**
     * @return a converter that maps between this enum's numeric and text representations
     */
    public static ProtoEnum.EnumConverter<PhysicalStreamType> converter() {
      return PhysicalStreamTypeConverter.INSTANCE;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value, or null if unknown.
     */
    public static PhysicalStreamType forNumber(int value) {
      return PhysicalStreamTypeConverter.INSTANCE.forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @param other Fallback value in case the value is not known.
     * @return The enum associated with the given numeric wire value, or the fallback value if unknown.
     */
    public static PhysicalStreamType forNumberOr(int number, PhysicalStreamType other) {
      PhysicalStreamType value = forNumber(number);
      return value == null ? other : value;
    }

    enum PhysicalStreamTypeConverter implements ProtoEnum.EnumConverter<PhysicalStreamType> {
      INSTANCE;

      private static final PhysicalStreamType[] lookup = new PhysicalStreamType[4];

      static {
        lookup[0] = UNSPECIFIED;
        lookup[1] = TRIPLES;
        lookup[2] = QUADS;
        lookup[3] = GRAPHS;
      }

      @Override
      public final PhysicalStreamType forNumber(final int value) {
        if (value >= 0 && value < lookup.length) {
          return lookup[value];
        }
        return null;
      }

      @Override
      public final PhysicalStreamType forName(final CharSequence value) {
        switch (value.length()) {
          case 5: {
            if ("QUADS" == value) {
              return QUADS;
            }
            break;
          }
          case 6: {
            if ("GRAPHS" == value) {
              return GRAPHS;
            }
            break;
          }
          case 7: {
            if ("TRIPLES" == value) {
              return TRIPLES;
            }
            break;
          }
          case 11: {
            if ("UNSPECIFIED" == value) {
              return UNSPECIFIED;
            }
            break;
          }
        }
        return null;
      }
    }
  }

  /**
   * Protobuf enum {@code LogicalStreamType}
   */
  public enum LogicalStreamType implements ProtoEnum<LogicalStreamType> {
    /**
     * <code>UNSPECIFIED = 0;</code>
     */
    UNSPECIFIED("UNSPECIFIED", 0),

    /**
     * <code>FLAT_TRIPLES = 1;</code>
     */
    FLAT_TRIPLES("FLAT_TRIPLES", 1),

    /**
     * <code>FLAT_QUADS = 2;</code>
     */
    FLAT_QUADS("FLAT_QUADS", 2),

    /**
     * <code>GRAPHS = 3;</code>
     */
    GRAPHS("GRAPHS", 3),

    /**
     * <code>DATASETS = 4;</code>
     */
    DATASETS("DATASETS", 4),

    /**
     * <code>SUBJECT_GRAPHS = 13;</code>
     */
    SUBJECT_GRAPHS("SUBJECT_GRAPHS", 13),

    /**
     * <code>NAMED_GRAPHS = 14;</code>
     */
    NAMED_GRAPHS("NAMED_GRAPHS", 14),

    /**
     * <code>TIMESTAMPED_NAMED_GRAPHS = 114;</code>
     */
    TIMESTAMPED_NAMED_GRAPHS("TIMESTAMPED_NAMED_GRAPHS", 114);

    /**
     * <code>UNSPECIFIED = 0;</code>
     */
    public static final int UNSPECIFIED_VALUE = 0;

    /**
     * <code>FLAT_TRIPLES = 1;</code>
     */
    public static final int FLAT_TRIPLES_VALUE = 1;

    /**
     * <code>FLAT_QUADS = 2;</code>
     */
    public static final int FLAT_QUADS_VALUE = 2;

    /**
     * <code>GRAPHS = 3;</code>
     */
    public static final int GRAPHS_VALUE = 3;

    /**
     * <code>DATASETS = 4;</code>
     */
    public static final int DATASETS_VALUE = 4;

    /**
     * <code>SUBJECT_GRAPHS = 13;</code>
     */
    public static final int SUBJECT_GRAPHS_VALUE = 13;

    /**
     * <code>NAMED_GRAPHS = 14;</code>
     */
    public static final int NAMED_GRAPHS_VALUE = 14;

    /**
     * <code>TIMESTAMPED_NAMED_GRAPHS = 114;</code>
     */
    public static final int TIMESTAMPED_NAMED_GRAPHS_VALUE = 114;

    private final String name;

    private final int number;

    private LogicalStreamType(String name, int number) {
      this.name = name;
      this.number = number;
    }

    /**
     * @return the string representation of enum entry
     */
    @Override
    public String getName() {
      return name;
    }

    /**
     * @return the numeric wire value of this enum entry
     */
    @Override
    public int getNumber() {
      return number;
    }

    /**
     * @return a converter that maps between this enum's numeric and text representations
     */
    public static ProtoEnum.EnumConverter<LogicalStreamType> converter() {
      return LogicalStreamTypeConverter.INSTANCE;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value, or null if unknown.
     */
    public static LogicalStreamType forNumber(int value) {
      return LogicalStreamTypeConverter.INSTANCE.forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @param other Fallback value in case the value is not known.
     * @return The enum associated with the given numeric wire value, or the fallback value if unknown.
     */
    public static LogicalStreamType forNumberOr(int number, LogicalStreamType other) {
      LogicalStreamType value = forNumber(number);
      return value == null ? other : value;
    }

    enum LogicalStreamTypeConverter implements ProtoEnum.EnumConverter<LogicalStreamType> {
      INSTANCE;

      @Override
      public final LogicalStreamType forNumber(final int value) {
        switch(value) {
          case 0: return UNSPECIFIED;
          case 1: return FLAT_TRIPLES;
          case 2: return FLAT_QUADS;
          case 3: return GRAPHS;
          case 4: return DATASETS;
          case 13: return SUBJECT_GRAPHS;
          case 14: return NAMED_GRAPHS;
          case 114: return TIMESTAMPED_NAMED_GRAPHS;
          default: return null;
        }
      }

      @Override
      public final LogicalStreamType forName(final CharSequence value) {
        switch (value.length()) {
          case 6: {
            if ("GRAPHS" == value) {
              return GRAPHS;
            }
            break;
          }
          case 8: {
            if ("DATASETS" == value) {
              return DATASETS;
            }
            break;
          }
          case 10: {
            if ("FLAT_QUADS" == value) {
              return FLAT_QUADS;
            }
            break;
          }
          case 11: {
            if ("UNSPECIFIED" == value) {
              return UNSPECIFIED;
            }
            break;
          }
          case 12: {
            if ("FLAT_TRIPLES" == value) {
              return FLAT_TRIPLES;
            }
            if ("NAMED_GRAPHS" == value) {
              return NAMED_GRAPHS;
            }
            break;
          }
          case 14: {
            if ("SUBJECT_GRAPHS" == value) {
              return SUBJECT_GRAPHS;
            }
            break;
          }
          case 24: {
            if ("TIMESTAMPED_NAMED_GRAPHS" == value) {
              return TIMESTAMPED_NAMED_GRAPHS;
            }
            break;
          }
        }
        return null;
      }
    }
  }

  /**
   * Protobuf type {@code RdfIri}
   */
  public static final class RdfIri extends ProtoMessage<RdfIri> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 prefix_id = 1;</code>
     */
    private int prefixId;

    /**
     * <code>optional uint32 name_id = 2;</code>
     */
    private int nameId;

    private RdfIri() {
    }

    /**
     * @return a new empty instance of {@code RdfIri}
     */
    public static RdfIri newInstance() {
      return new RdfIri();
    }

    /**
     * <code>optional uint32 prefix_id = 1;</code>
     * @return whether the prefixId field is set
     */
    public boolean hasPrefixId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 prefix_id = 1;</code>
     * @return this
     */
    public RdfIri clearPrefixId() {
      bitField0_ &= ~0x00000001;
      prefixId = 0;
      return this;
    }

    /**
     * <code>optional uint32 prefix_id = 1;</code>
     * @return the prefixId
     */
    public int getPrefixId() {
      return prefixId;
    }

    /**
     * <code>optional uint32 prefix_id = 1;</code>
     * @param value the prefixId to set
     * @return this
     */
    public RdfIri setPrefixId(final int value) {
      bitField0_ |= 0x00000001;
      prefixId = value;
      return this;
    }

    /**
     * <code>optional uint32 name_id = 2;</code>
     * @return whether the nameId field is set
     */
    public boolean hasNameId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 name_id = 2;</code>
     * @return this
     */
    public RdfIri clearNameId() {
      bitField0_ &= ~0x00000002;
      nameId = 0;
      return this;
    }

    /**
     * <code>optional uint32 name_id = 2;</code>
     * @return the nameId
     */
    public int getNameId() {
      return nameId;
    }

    /**
     * <code>optional uint32 name_id = 2;</code>
     * @param value the nameId to set
     * @return this
     */
    public RdfIri setNameId(final int value) {
      bitField0_ |= 0x00000002;
      nameId = value;
      return this;
    }

    @Override
    public RdfIri copyFrom(final RdfIri other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        prefixId = other.prefixId;
        nameId = other.nameId;
      }
      return this;
    }

    @Override
    public RdfIri mergeFrom(final RdfIri other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasPrefixId()) {
        setPrefixId(other.prefixId);
      }
      if (other.hasNameId()) {
        setNameId(other.nameId);
      }
      return this;
    }

    @Override
    public RdfIri clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      prefixId = 0;
      nameId = 0;
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof RdfIri)) {
        return false;
      }
      RdfIri other = (RdfIri) o;
      return bitField0_ == other.bitField0_
        && (!hasPrefixId() || prefixId == other.prefixId)
        && (!hasNameId() || nameId == other.nameId);
    }

    @Override
    public void writeTo(final CodedOutputStream output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(prefixId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(nameId);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(prefixId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(nameId);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public RdfIri mergeFrom(final CodedInputStream input) throws IOException {
      // Enabled Fall-Through Optimization (Quickbuf)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // prefixId
            prefixId = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // nameId
            nameId = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public RdfIri clone() {
      return new RdfIri().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static RdfIri parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new RdfIri(), data).checkInitialized();
    }

    public static RdfIri parseFrom(final CodedInputStream input) throws IOException {
      return ProtoMessage.mergeFrom(new RdfIri(), input).checkInitialized();
    }

    /**
     * @return factory for creating RdfIri messages
     */
    public static MessageFactory<RdfIri> getFactory() {
      return RdfIriFactory.INSTANCE;
    }

    private enum RdfIriFactory implements MessageFactory<RdfIri> {
      INSTANCE;

      @Override
      public RdfIri create() {
        return RdfIri.newInstance();
      }
    }
  }

  /**
   * Protobuf type {@code RdfLiteral}
   */
  public static final class RdfLiteral extends ProtoMessage<RdfLiteral> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional string lex = 1;</code>
     */
    private String lex = null;

    /**
     * <code>optional string langtag = 2;</code>
     */
    private String langtag = null;

    /**
     * <code>optional uint32 datatype = 3;</code>
     */
    private int datatype;

    private RdfLiteral() {
    }

    /**
     * @return a new empty instance of {@code RdfLiteral}
     */
    public static RdfLiteral newInstance() {
      return new RdfLiteral();
    }

    public boolean hasLiteralKind() {
      return (((bitField0_ & 0x00000003)) != 0);
    }

    public RdfLiteral clearLiteralKind() {
      if (hasLiteralKind()) {
        clearLangtag();
        clearDatatype();
      }
      return this;
    }

    private void clearLiteralKindOtherLangtag() {
      if ((((bitField0_ & 0x00000002)) != 0)) {
        clearDatatype();
      }
    }

    private void clearLiteralKindOtherDatatype() {
      if ((((bitField0_ & 0x00000001)) != 0)) {
        clearLangtag();
      }
    }

    private void initLex() {
      if (lex == null) {
        lex = "";
      }
    }

    /**
     * <code>optional string lex = 1;</code>
     * @return whether the lex field is set
     */
    public boolean hasLex() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional string lex = 1;</code>
     * @return this
     */
    public RdfLiteral clearLex() {
      bitField0_ &= ~0x00000004;
      if (lex != null) {
        lex = "";
      }
      return this;
    }

    /**
     * <code>optional string lex = 1;</code>
     * @return the lex
     */
    public String getLex() {
      initLex();
      return lex;
    }

    /**
     * <code>optional string lex = 1;</code>
     * @param value the lex to set
     * @return this
     */
    public RdfLiteral setLex(final String value) {
      initLex();
      bitField0_ |= 0x00000004;
      lex = value;
      return this;
    }

    private void initLangtag() {
      if (langtag == null) {
        langtag = "";
      }
    }

    /**
     * <code>optional string langtag = 2;</code>
     * @return whether the langtag field is set
     */
    public boolean hasLangtag() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional string langtag = 2;</code>
     * @return this
     */
    public RdfLiteral clearLangtag() {
      bitField0_ &= ~0x00000001;
      if (langtag != null) {
        langtag = "";
      }
      return this;
    }

    /**
     * <code>optional string langtag = 2;</code>
     * @return the langtag
     */
    public String getLangtag() {
      initLangtag();
      return langtag;
    }

    /**
     * <code>optional string langtag = 2;</code>
     * @param value the langtag to set
     * @return this
     */
    public RdfLiteral setLangtag(final String value) {
      clearLiteralKindOtherLangtag();
      initLangtag();
      bitField0_ |= 0x00000001;
      langtag = value;
      return this;
    }

    /**
     * <code>optional uint32 datatype = 3;</code>
     * @return whether the datatype field is set
     */
    public boolean hasDatatype() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 datatype = 3;</code>
     * @return this
     */
    public RdfLiteral clearDatatype() {
      bitField0_ &= ~0x00000002;
      datatype = 0;
      return this;
    }

    /**
     * <code>optional uint32 datatype = 3;</code>
     * @return the datatype
     */
    public int getDatatype() {
      return datatype;
    }

    /**
     * <code>optional uint32 datatype = 3;</code>
     * @param value the datatype to set
     * @return this
     */
    public RdfLiteral setDatatype(final int value) {
      clearLiteralKindOtherDatatype();
      bitField0_ |= 0x00000002;
      datatype = value;
      return this;
    }

    @Override
    public RdfLiteral copyFrom(final RdfLiteral other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        if (other.hasLex()) {
          initLex();
          lex = other.lex;
        } else {
          clearLex();
        }
        if (other.hasLangtag()) {
          initLangtag();
          langtag = other.langtag;
        } else {
          clearLangtag();
        }
        datatype = other.datatype;
      }
      return this;
    }

    @Override
    public RdfLiteral mergeFrom(final RdfLiteral other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasLex()) {
        lex = other.lex;
      }
      if (other.hasLangtag()) {
        langtag = other.langtag;
      }
      if (other.hasDatatype()) {
        setDatatype(other.datatype);
      }
      return this;
    }

    @Override
    public RdfLiteral clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (lex != null) {
        lex = "";
      }
      if (langtag != null) {
        langtag = "";
      }
      datatype = 0;
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof RdfLiteral)) {
        return false;
      }
      RdfLiteral other = (RdfLiteral) o;
      return bitField0_ == other.bitField0_
        && (!hasLex() || lex.equals(other.lex))
        && (!hasLangtag() || langtag.equals(other.langtag))
        && (!hasDatatype() || datatype == other.datatype);
    }

    @Override
    public void writeTo(final CodedOutputStream output) throws IOException {
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 10);
        output.writeStringNoTag(lex);
      }
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 18);
        output.writeStringNoTag(langtag);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 24);
        output.writeUInt32NoTag(datatype);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + CodedOutputStream.computeStringSizeNoTag(lex);
      }
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + CodedOutputStream.computeStringSizeNoTag(langtag);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(datatype);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public RdfLiteral mergeFrom(final CodedInputStream input) throws IOException {
      // Enabled Fall-Through Optimization (Quickbuf)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 10: {
            // lex
            initLex();
            lex = input.readStringRequireUtf8();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // langtag
            clearLiteralKindOtherLangtag();
            initLangtag();
            langtag = input.readStringRequireUtf8();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // datatype
            clearLiteralKindOtherDatatype();
            datatype = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public RdfLiteral clone() {
      return new RdfLiteral().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static RdfLiteral parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new RdfLiteral(), data).checkInitialized();
    }

    public static RdfLiteral parseFrom(final CodedInputStream input) throws IOException {
      return ProtoMessage.mergeFrom(new RdfLiteral(), input).checkInitialized();
    }

    /**
     * @return factory for creating RdfLiteral messages
     */
    public static MessageFactory<RdfLiteral> getFactory() {
      return RdfLiteralFactory.INSTANCE;
    }

    private enum RdfLiteralFactory implements MessageFactory<RdfLiteral> {
      INSTANCE;

      @Override
      public RdfLiteral create() {
        return RdfLiteral.newInstance();
      }
    }
  }

  /**
   * Protobuf type {@code RdfDefaultGraph}
   */
  public static final class RdfDefaultGraph extends ProtoMessage<RdfDefaultGraph> implements Cloneable {
    private static final long serialVersionUID = 0L;

    private RdfDefaultGraph() {
    }

    /**
     * @return a new empty instance of {@code RdfDefaultGraph}
     */
    public static RdfDefaultGraph newInstance() {
      return new RdfDefaultGraph();
    }

    @Override
    public RdfDefaultGraph copyFrom(final RdfDefaultGraph other) {
      cachedSize = other.cachedSize;
      return this;
    }

    @Override
    public RdfDefaultGraph mergeFrom(final RdfDefaultGraph other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      return this;
    }

    @Override
    public RdfDefaultGraph clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof RdfDefaultGraph)) {
        return false;
      }
      RdfDefaultGraph other = (RdfDefaultGraph) o;
      return true;
    }

    @Override
    public void writeTo(final CodedOutputStream output) throws IOException {
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public RdfDefaultGraph mergeFrom(final CodedInputStream input) throws IOException {
      // Enabled Fall-Through Optimization (Quickbuf)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public RdfDefaultGraph clone() {
      return new RdfDefaultGraph().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static RdfDefaultGraph parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new RdfDefaultGraph(), data).checkInitialized();
    }

    public static RdfDefaultGraph parseFrom(final CodedInputStream input) throws IOException {
      return ProtoMessage.mergeFrom(new RdfDefaultGraph(), input).checkInitialized();
    }

    /**
     * @return factory for creating RdfDefaultGraph messages
     */
    public static MessageFactory<RdfDefaultGraph> getFactory() {
      return RdfDefaultGraphFactory.INSTANCE;
    }

    private enum RdfDefaultGraphFactory implements MessageFactory<RdfDefaultGraph> {
      INSTANCE;

      @Override
      public RdfDefaultGraph create() {
        return RdfDefaultGraph.newInstance();
      }
    }
  }

  /**
   * Protobuf type {@code RdfTriple}
   */
  public static final class RdfTriple extends ProtoMessage<RdfTriple> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri s_iri = 1;</code>
     */
    private RdfIri sIri = null;

    /**
     * <code>optional string s_bnode = 2;</code>
     */
    private String sBnode = null;

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral s_literal = 3;</code>
     */
    private RdfLiteral sLiteral = null;

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple s_triple_term = 4;</code>
     */
    private RdfTriple sTripleTerm = null;

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri p_iri = 5;</code>
     */
    private RdfIri pIri = null;

    /**
     * <code>optional string p_bnode = 6;</code>
     */
    private String pBnode = null;

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral p_literal = 7;</code>
     */
    private RdfLiteral pLiteral = null;

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple p_triple_term = 8;</code>
     */
    private RdfTriple pTripleTerm = null;

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri o_iri = 9;</code>
     */
    private RdfIri oIri = null;

    /**
     * <code>optional string o_bnode = 10;</code>
     */
    private String oBnode = null;

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral o_literal = 11;</code>
     */
    private RdfLiteral oLiteral = null;

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple o_triple_term = 12;</code>
     */
    private RdfTriple oTripleTerm = null;

    private RdfTriple() {
    }

    /**
     * @return a new empty instance of {@code RdfTriple}
     */
    public static RdfTriple newInstance() {
      return new RdfTriple();
    }

    public boolean hasSubject() {
      return (((bitField0_ & 0x00000f00)) != 0);
    }

    public RdfTriple clearSubject() {
      if (hasSubject()) {
        clearSIri();
        clearSBnode();
        clearSLiteral();
        clearSTripleTerm();
      }
      return this;
    }

    private void clearSubjectOtherSIri() {
      if ((((bitField0_ & 0x00000e00)) != 0)) {
        clearSBnode();
        clearSLiteral();
        clearSTripleTerm();
      }
    }

    private void clearSubjectOtherSBnode() {
      if ((((bitField0_ & 0x00000d00)) != 0)) {
        clearSIri();
        clearSLiteral();
        clearSTripleTerm();
      }
    }

    private void clearSubjectOtherSLiteral() {
      if ((((bitField0_ & 0x00000b00)) != 0)) {
        clearSIri();
        clearSBnode();
        clearSTripleTerm();
      }
    }

    private void clearSubjectOtherSTripleTerm() {
      if ((((bitField0_ & 0x00000700)) != 0)) {
        clearSIri();
        clearSBnode();
        clearSLiteral();
      }
    }

    public boolean hasPredicate() {
      return (((bitField0_ & 0x000000f0)) != 0);
    }

    public RdfTriple clearPredicate() {
      if (hasPredicate()) {
        clearPIri();
        clearPBnode();
        clearPLiteral();
        clearPTripleTerm();
      }
      return this;
    }

    private void clearPredicateOtherPIri() {
      if ((((bitField0_ & 0x000000e0)) != 0)) {
        clearPBnode();
        clearPLiteral();
        clearPTripleTerm();
      }
    }

    private void clearPredicateOtherPBnode() {
      if ((((bitField0_ & 0x000000d0)) != 0)) {
        clearPIri();
        clearPLiteral();
        clearPTripleTerm();
      }
    }

    private void clearPredicateOtherPLiteral() {
      if ((((bitField0_ & 0x000000b0)) != 0)) {
        clearPIri();
        clearPBnode();
        clearPTripleTerm();
      }
    }

    private void clearPredicateOtherPTripleTerm() {
      if ((((bitField0_ & 0x00000070)) != 0)) {
        clearPIri();
        clearPBnode();
        clearPLiteral();
      }
    }

    public boolean hasObject() {
      return (((bitField0_ & 0x0000000f)) != 0);
    }

    public RdfTriple clearObject() {
      if (hasObject()) {
        clearOIri();
        clearOBnode();
        clearOLiteral();
        clearOTripleTerm();
      }
      return this;
    }

    private void clearObjectOtherOIri() {
      if ((((bitField0_ & 0x0000000e)) != 0)) {
        clearOBnode();
        clearOLiteral();
        clearOTripleTerm();
      }
    }

    private void clearObjectOtherOBnode() {
      if ((((bitField0_ & 0x0000000d)) != 0)) {
        clearOIri();
        clearOLiteral();
        clearOTripleTerm();
      }
    }

    private void clearObjectOtherOLiteral() {
      if ((((bitField0_ & 0x0000000b)) != 0)) {
        clearOIri();
        clearOBnode();
        clearOTripleTerm();
      }
    }

    private void clearObjectOtherOTripleTerm() {
      if ((((bitField0_ & 0x00000007)) != 0)) {
        clearOIri();
        clearOBnode();
        clearOLiteral();
      }
    }

    private void initSIri() {
      if (sIri == null) {
        sIri = RdfIri.newInstance();
      }
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri s_iri = 1;</code>
     * @return whether the sIri field is set
     */
    public boolean hasSIri() {
      return (bitField0_ & 0x00000100) != 0;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri s_iri = 1;</code>
     * @return this
     */
    public RdfTriple clearSIri() {
      bitField0_ &= ~0x00000100;
      if (sIri != null) {
        sIri.clear();
      }
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri s_iri = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableSIri()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RdfIri getSIri() {
      initSIri();
      return sIri;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri s_iri = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RdfIri getMutableSIri() {
      clearSubjectOtherSIri();
      initSIri();
      bitField0_ |= 0x00000100;
      return sIri;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri s_iri = 1;</code>
     * @param value the sIri to set
     * @return this
     */
    public RdfTriple setSIri(final RdfIri value) {
      clearSubjectOtherSIri();
      initSIri();
      bitField0_ |= 0x00000100;
      sIri.copyFrom(value);
      return this;
    }

    private void initSBnode() {
      if (sBnode == null) {
        sBnode = "";
      }
    }

    /**
     * <code>optional string s_bnode = 2;</code>
     * @return whether the sBnode field is set
     */
    public boolean hasSBnode() {
      return (bitField0_ & 0x00000200) != 0;
    }

    /**
     * <code>optional string s_bnode = 2;</code>
     * @return this
     */
    public RdfTriple clearSBnode() {
      bitField0_ &= ~0x00000200;
      if (sBnode != null) {
        sBnode = "";
      }
      return this;
    }

    /**
     * <code>optional string s_bnode = 2;</code>
     * @return the sBnode
     */
    public String getSBnode() {
      initSBnode();
      return sBnode;
    }

    /**
     * <code>optional string s_bnode = 2;</code>
     * @param value the sBnode to set
     * @return this
     */
    public RdfTriple setSBnode(final String value) {
      clearSubjectOtherSBnode();
      initSBnode();
      bitField0_ |= 0x00000200;
      sBnode = value;
      return this;
    }

    private void initSLiteral() {
      if (sLiteral == null) {
        sLiteral = RdfLiteral.newInstance();
      }
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral s_literal = 3;</code>
     * @return whether the sLiteral field is set
     */
    public boolean hasSLiteral() {
      return (bitField0_ & 0x00000400) != 0;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral s_literal = 3;</code>
     * @return this
     */
    public RdfTriple clearSLiteral() {
      bitField0_ &= ~0x00000400;
      if (sLiteral != null) {
        sLiteral.clear();
      }
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral s_literal = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableSLiteral()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RdfLiteral getSLiteral() {
      initSLiteral();
      return sLiteral;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral s_literal = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RdfLiteral getMutableSLiteral() {
      clearSubjectOtherSLiteral();
      initSLiteral();
      bitField0_ |= 0x00000400;
      return sLiteral;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral s_literal = 3;</code>
     * @param value the sLiteral to set
     * @return this
     */
    public RdfTriple setSLiteral(final RdfLiteral value) {
      clearSubjectOtherSLiteral();
      initSLiteral();
      bitField0_ |= 0x00000400;
      sLiteral.copyFrom(value);
      return this;
    }

    private void initSTripleTerm() {
      if (sTripleTerm == null) {
        sTripleTerm = RdfTriple.newInstance();
      }
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple s_triple_term = 4;</code>
     * @return whether the sTripleTerm field is set
     */
    public boolean hasSTripleTerm() {
      return (bitField0_ & 0x00000800) != 0;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple s_triple_term = 4;</code>
     * @return this
     */
    public RdfTriple clearSTripleTerm() {
      bitField0_ &= ~0x00000800;
      if (sTripleTerm != null) {
        sTripleTerm.clear();
      }
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple s_triple_term = 4;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableSTripleTerm()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RdfTriple getSTripleTerm() {
      initSTripleTerm();
      return sTripleTerm;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple s_triple_term = 4;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RdfTriple getMutableSTripleTerm() {
      clearSubjectOtherSTripleTerm();
      initSTripleTerm();
      bitField0_ |= 0x00000800;
      return sTripleTerm;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple s_triple_term = 4;</code>
     * @param value the sTripleTerm to set
     * @return this
     */
    public RdfTriple setSTripleTerm(final RdfTriple value) {
      clearSubjectOtherSTripleTerm();
      initSTripleTerm();
      bitField0_ |= 0x00000800;
      sTripleTerm.copyFrom(value);
      return this;
    }

    private void initPIri() {
      if (pIri == null) {
        pIri = RdfIri.newInstance();
      }
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri p_iri = 5;</code>
     * @return whether the pIri field is set
     */
    public boolean hasPIri() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri p_iri = 5;</code>
     * @return this
     */
    public RdfTriple clearPIri() {
      bitField0_ &= ~0x00000010;
      if (pIri != null) {
        pIri.clear();
      }
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri p_iri = 5;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutablePIri()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RdfIri getPIri() {
      initPIri();
      return pIri;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri p_iri = 5;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RdfIri getMutablePIri() {
      clearPredicateOtherPIri();
      initPIri();
      bitField0_ |= 0x00000010;
      return pIri;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri p_iri = 5;</code>
     * @param value the pIri to set
     * @return this
     */
    public RdfTriple setPIri(final RdfIri value) {
      clearPredicateOtherPIri();
      initPIri();
      bitField0_ |= 0x00000010;
      pIri.copyFrom(value);
      return this;
    }

    private void initPBnode() {
      if (pBnode == null) {
        pBnode = "";
      }
    }

    /**
     * <code>optional string p_bnode = 6;</code>
     * @return whether the pBnode field is set
     */
    public boolean hasPBnode() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>optional string p_bnode = 6;</code>
     * @return this
     */
    public RdfTriple clearPBnode() {
      bitField0_ &= ~0x00000020;
      if (pBnode != null) {
        pBnode = "";
      }
      return this;
    }

    /**
     * <code>optional string p_bnode = 6;</code>
     * @return the pBnode
     */
    public String getPBnode() {
      initPBnode();
      return pBnode;
    }

    /**
     * <code>optional string p_bnode = 6;</code>
     * @param value the pBnode to set
     * @return this
     */
    public RdfTriple setPBnode(final String value) {
      clearPredicateOtherPBnode();
      initPBnode();
      bitField0_ |= 0x00000020;
      pBnode = value;
      return this;
    }

    private void initPLiteral() {
      if (pLiteral == null) {
        pLiteral = RdfLiteral.newInstance();
      }
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral p_literal = 7;</code>
     * @return whether the pLiteral field is set
     */
    public boolean hasPLiteral() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral p_literal = 7;</code>
     * @return this
     */
    public RdfTriple clearPLiteral() {
      bitField0_ &= ~0x00000040;
      if (pLiteral != null) {
        pLiteral.clear();
      }
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral p_literal = 7;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutablePLiteral()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RdfLiteral getPLiteral() {
      initPLiteral();
      return pLiteral;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral p_literal = 7;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RdfLiteral getMutablePLiteral() {
      clearPredicateOtherPLiteral();
      initPLiteral();
      bitField0_ |= 0x00000040;
      return pLiteral;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral p_literal = 7;</code>
     * @param value the pLiteral to set
     * @return this
     */
    public RdfTriple setPLiteral(final RdfLiteral value) {
      clearPredicateOtherPLiteral();
      initPLiteral();
      bitField0_ |= 0x00000040;
      pLiteral.copyFrom(value);
      return this;
    }

    private void initPTripleTerm() {
      if (pTripleTerm == null) {
        pTripleTerm = RdfTriple.newInstance();
      }
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple p_triple_term = 8;</code>
     * @return whether the pTripleTerm field is set
     */
    public boolean hasPTripleTerm() {
      return (bitField0_ & 0x00000080) != 0;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple p_triple_term = 8;</code>
     * @return this
     */
    public RdfTriple clearPTripleTerm() {
      bitField0_ &= ~0x00000080;
      if (pTripleTerm != null) {
        pTripleTerm.clear();
      }
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple p_triple_term = 8;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutablePTripleTerm()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RdfTriple getPTripleTerm() {
      initPTripleTerm();
      return pTripleTerm;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple p_triple_term = 8;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RdfTriple getMutablePTripleTerm() {
      clearPredicateOtherPTripleTerm();
      initPTripleTerm();
      bitField0_ |= 0x00000080;
      return pTripleTerm;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple p_triple_term = 8;</code>
     * @param value the pTripleTerm to set
     * @return this
     */
    public RdfTriple setPTripleTerm(final RdfTriple value) {
      clearPredicateOtherPTripleTerm();
      initPTripleTerm();
      bitField0_ |= 0x00000080;
      pTripleTerm.copyFrom(value);
      return this;
    }

    private void initOIri() {
      if (oIri == null) {
        oIri = RdfIri.newInstance();
      }
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri o_iri = 9;</code>
     * @return whether the oIri field is set
     */
    public boolean hasOIri() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri o_iri = 9;</code>
     * @return this
     */
    public RdfTriple clearOIri() {
      bitField0_ &= ~0x00000001;
      if (oIri != null) {
        oIri.clear();
      }
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri o_iri = 9;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableOIri()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RdfIri getOIri() {
      initOIri();
      return oIri;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri o_iri = 9;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RdfIri getMutableOIri() {
      clearObjectOtherOIri();
      initOIri();
      bitField0_ |= 0x00000001;
      return oIri;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri o_iri = 9;</code>
     * @param value the oIri to set
     * @return this
     */
    public RdfTriple setOIri(final RdfIri value) {
      clearObjectOtherOIri();
      initOIri();
      bitField0_ |= 0x00000001;
      oIri.copyFrom(value);
      return this;
    }

    private void initOBnode() {
      if (oBnode == null) {
        oBnode = "";
      }
    }

    /**
     * <code>optional string o_bnode = 10;</code>
     * @return whether the oBnode field is set
     */
    public boolean hasOBnode() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional string o_bnode = 10;</code>
     * @return this
     */
    public RdfTriple clearOBnode() {
      bitField0_ &= ~0x00000002;
      if (oBnode != null) {
        oBnode = "";
      }
      return this;
    }

    /**
     * <code>optional string o_bnode = 10;</code>
     * @return the oBnode
     */
    public String getOBnode() {
      initOBnode();
      return oBnode;
    }

    /**
     * <code>optional string o_bnode = 10;</code>
     * @param value the oBnode to set
     * @return this
     */
    public RdfTriple setOBnode(final String value) {
      clearObjectOtherOBnode();
      initOBnode();
      bitField0_ |= 0x00000002;
      oBnode = value;
      return this;
    }

    private void initOLiteral() {
      if (oLiteral == null) {
        oLiteral = RdfLiteral.newInstance();
      }
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral o_literal = 11;</code>
     * @return whether the oLiteral field is set
     */
    public boolean hasOLiteral() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral o_literal = 11;</code>
     * @return this
     */
    public RdfTriple clearOLiteral() {
      bitField0_ &= ~0x00000004;
      if (oLiteral != null) {
        oLiteral.clear();
      }
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral o_literal = 11;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableOLiteral()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RdfLiteral getOLiteral() {
      initOLiteral();
      return oLiteral;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral o_literal = 11;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RdfLiteral getMutableOLiteral() {
      clearObjectOtherOLiteral();
      initOLiteral();
      bitField0_ |= 0x00000004;
      return oLiteral;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral o_literal = 11;</code>
     * @param value the oLiteral to set
     * @return this
     */
    public RdfTriple setOLiteral(final RdfLiteral value) {
      clearObjectOtherOLiteral();
      initOLiteral();
      bitField0_ |= 0x00000004;
      oLiteral.copyFrom(value);
      return this;
    }

    private void initOTripleTerm() {
      if (oTripleTerm == null) {
        oTripleTerm = RdfTriple.newInstance();
      }
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple o_triple_term = 12;</code>
     * @return whether the oTripleTerm field is set
     */
    public boolean hasOTripleTerm() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple o_triple_term = 12;</code>
     * @return this
     */
    public RdfTriple clearOTripleTerm() {
      bitField0_ &= ~0x00000008;
      if (oTripleTerm != null) {
        oTripleTerm.clear();
      }
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple o_triple_term = 12;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableOTripleTerm()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RdfTriple getOTripleTerm() {
      initOTripleTerm();
      return oTripleTerm;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple o_triple_term = 12;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RdfTriple getMutableOTripleTerm() {
      clearObjectOtherOTripleTerm();
      initOTripleTerm();
      bitField0_ |= 0x00000008;
      return oTripleTerm;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple o_triple_term = 12;</code>
     * @param value the oTripleTerm to set
     * @return this
     */
    public RdfTriple setOTripleTerm(final RdfTriple value) {
      clearObjectOtherOTripleTerm();
      initOTripleTerm();
      bitField0_ |= 0x00000008;
      oTripleTerm.copyFrom(value);
      return this;
    }

    @Override
    public RdfTriple copyFrom(final RdfTriple other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        if (other.hasSIri()) {
          initSIri();
          sIri.copyFrom(other.sIri);
        } else {
          clearSIri();
        }
        if (other.hasSBnode()) {
          initSBnode();
          sBnode = other.sBnode;
        } else {
          clearSBnode();
        }
        if (other.hasSLiteral()) {
          initSLiteral();
          sLiteral.copyFrom(other.sLiteral);
        } else {
          clearSLiteral();
        }
        if (other.hasSTripleTerm()) {
          initSTripleTerm();
          sTripleTerm.copyFrom(other.sTripleTerm);
        } else {
          clearSTripleTerm();
        }
        if (other.hasPIri()) {
          initPIri();
          pIri.copyFrom(other.pIri);
        } else {
          clearPIri();
        }
        if (other.hasPBnode()) {
          initPBnode();
          pBnode = other.pBnode;
        } else {
          clearPBnode();
        }
        if (other.hasPLiteral()) {
          initPLiteral();
          pLiteral.copyFrom(other.pLiteral);
        } else {
          clearPLiteral();
        }
        if (other.hasPTripleTerm()) {
          initPTripleTerm();
          pTripleTerm.copyFrom(other.pTripleTerm);
        } else {
          clearPTripleTerm();
        }
        if (other.hasOIri()) {
          initOIri();
          oIri.copyFrom(other.oIri);
        } else {
          clearOIri();
        }
        if (other.hasOBnode()) {
          initOBnode();
          oBnode = other.oBnode;
        } else {
          clearOBnode();
        }
        if (other.hasOLiteral()) {
          initOLiteral();
          oLiteral.copyFrom(other.oLiteral);
        } else {
          clearOLiteral();
        }
        if (other.hasOTripleTerm()) {
          initOTripleTerm();
          oTripleTerm.copyFrom(other.oTripleTerm);
        } else {
          clearOTripleTerm();
        }
      }
      return this;
    }

    @Override
    public RdfTriple mergeFrom(final RdfTriple other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasSIri()) {
        getMutableSIri().mergeFrom(other.sIri);
      }
      if (other.hasSBnode()) {
        sBnode = other.sBnode;
      }
      if (other.hasSLiteral()) {
        getMutableSLiteral().mergeFrom(other.sLiteral);
      }
      if (other.hasSTripleTerm()) {
        getMutableSTripleTerm().mergeFrom(other.sTripleTerm);
      }
      if (other.hasPIri()) {
        getMutablePIri().mergeFrom(other.pIri);
      }
      if (other.hasPBnode()) {
        pBnode = other.pBnode;
      }
      if (other.hasPLiteral()) {
        getMutablePLiteral().mergeFrom(other.pLiteral);
      }
      if (other.hasPTripleTerm()) {
        getMutablePTripleTerm().mergeFrom(other.pTripleTerm);
      }
      if (other.hasOIri()) {
        getMutableOIri().mergeFrom(other.oIri);
      }
      if (other.hasOBnode()) {
        oBnode = other.oBnode;
      }
      if (other.hasOLiteral()) {
        getMutableOLiteral().mergeFrom(other.oLiteral);
      }
      if (other.hasOTripleTerm()) {
        getMutableOTripleTerm().mergeFrom(other.oTripleTerm);
      }
      return this;
    }

    @Override
    public RdfTriple clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (sIri != null) {
        sIri.clear();
      }
      if (sBnode != null) {
        sBnode = "";
      }
      if (sLiteral != null) {
        sLiteral.clear();
      }
      if (sTripleTerm != null) {
        sTripleTerm.clear();
      }
      if (pIri != null) {
        pIri.clear();
      }
      if (pBnode != null) {
        pBnode = "";
      }
      if (pLiteral != null) {
        pLiteral.clear();
      }
      if (pTripleTerm != null) {
        pTripleTerm.clear();
      }
      if (oIri != null) {
        oIri.clear();
      }
      if (oBnode != null) {
        oBnode = "";
      }
      if (oLiteral != null) {
        oLiteral.clear();
      }
      if (oTripleTerm != null) {
        oTripleTerm.clear();
      }
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof RdfTriple)) {
        return false;
      }
      RdfTriple other = (RdfTriple) o;
      return bitField0_ == other.bitField0_
        && (!hasSIri() || sIri.equals(other.sIri))
        && (!hasSBnode() || sBnode.equals(other.sBnode))
        && (!hasSLiteral() || sLiteral.equals(other.sLiteral))
        && (!hasSTripleTerm() || sTripleTerm.equals(other.sTripleTerm))
        && (!hasPIri() || pIri.equals(other.pIri))
        && (!hasPBnode() || pBnode.equals(other.pBnode))
        && (!hasPLiteral() || pLiteral.equals(other.pLiteral))
        && (!hasPTripleTerm() || pTripleTerm.equals(other.pTripleTerm))
        && (!hasOIri() || oIri.equals(other.oIri))
        && (!hasOBnode() || oBnode.equals(other.oBnode))
        && (!hasOLiteral() || oLiteral.equals(other.oLiteral))
        && (!hasOTripleTerm() || oTripleTerm.equals(other.oTripleTerm));
    }

    @Override
    public void writeTo(final CodedOutputStream output) throws IOException {
      if ((bitField0_ & 0x00000100) != 0) {
        output.writeRawByte((byte) 10);
        output.writeUInt32NoTag(sIri.getCachedSize());
        sIri.writeTo(output);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        output.writeRawByte((byte) 18);
        output.writeStringNoTag(sBnode);
      }
      if ((bitField0_ & 0x00000400) != 0) {
        output.writeRawByte((byte) 26);
        output.writeUInt32NoTag(sLiteral.getCachedSize());
        sLiteral.writeTo(output);
      }
      if ((bitField0_ & 0x00000800) != 0) {
        output.writeRawByte((byte) 34);
        output.writeUInt32NoTag(sTripleTerm.getCachedSize());
        sTripleTerm.writeTo(output);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawByte((byte) 42);
        output.writeUInt32NoTag(pIri.getCachedSize());
        pIri.writeTo(output);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRawByte((byte) 50);
        output.writeStringNoTag(pBnode);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeRawByte((byte) 58);
        output.writeUInt32NoTag(pLiteral.getCachedSize());
        pLiteral.writeTo(output);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeRawByte((byte) 66);
        output.writeUInt32NoTag(pTripleTerm.getCachedSize());
        pTripleTerm.writeTo(output);
      }
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 74);
        output.writeUInt32NoTag(oIri.getCachedSize());
        oIri.writeTo(output);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 82);
        output.writeStringNoTag(oBnode);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 90);
        output.writeUInt32NoTag(oLiteral.getCachedSize());
        oLiteral.writeTo(output);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 98);
        output.writeUInt32NoTag(oTripleTerm.getCachedSize());
        oTripleTerm.writeTo(output);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000100) != 0) {
        final int dataSize = sIri.getSerializedSize();
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
      }
      if ((bitField0_ & 0x00000200) != 0) {
        size += 1 + CodedOutputStream.computeStringSizeNoTag(sBnode);
      }
      if ((bitField0_ & 0x00000400) != 0) {
        final int dataSize = sLiteral.getSerializedSize();
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
      }
      if ((bitField0_ & 0x00000800) != 0) {
        final int dataSize = sTripleTerm.getSerializedSize();
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
      }
      if ((bitField0_ & 0x00000010) != 0) {
        final int dataSize = pIri.getSerializedSize();
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += 1 + CodedOutputStream.computeStringSizeNoTag(pBnode);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        final int dataSize = pLiteral.getSerializedSize();
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
      }
      if ((bitField0_ & 0x00000080) != 0) {
        final int dataSize = pTripleTerm.getSerializedSize();
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
      }
      if ((bitField0_ & 0x00000001) != 0) {
        final int dataSize = oIri.getSerializedSize();
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + CodedOutputStream.computeStringSizeNoTag(oBnode);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        final int dataSize = oLiteral.getSerializedSize();
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
      }
      if ((bitField0_ & 0x00000008) != 0) {
        final int dataSize = oTripleTerm.getSerializedSize();
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public RdfTriple mergeFrom(final CodedInputStream input) throws IOException {
      // Enabled Fall-Through Optimization (Quickbuf)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 10: {
            // sIri
            clearSubjectOtherSIri();
            initSIri();
            ProtoMessage.mergeDelimitedFrom(sIri, input);
            bitField0_ |= 0x00000100;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // sBnode
            clearSubjectOtherSBnode();
            initSBnode();
            sBnode = input.readStringRequireUtf8();
            bitField0_ |= 0x00000200;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // sLiteral
            clearSubjectOtherSLiteral();
            initSLiteral();
            ProtoMessage.mergeDelimitedFrom(sLiteral, input);
            bitField0_ |= 0x00000400;
            tag = input.readTag();
            if (tag != 34) {
              break;
            }
          }
          case 34: {
            // sTripleTerm
            clearSubjectOtherSTripleTerm();
            initSTripleTerm();
            ProtoMessage.mergeDelimitedFrom(sTripleTerm, input);
            bitField0_ |= 0x00000800;
            tag = input.readTag();
            if (tag != 42) {
              break;
            }
          }
          case 42: {
            // pIri
            clearPredicateOtherPIri();
            initPIri();
            ProtoMessage.mergeDelimitedFrom(pIri, input);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 50) {
              break;
            }
          }
          case 50: {
            // pBnode
            clearPredicateOtherPBnode();
            initPBnode();
            pBnode = input.readStringRequireUtf8();
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 58) {
              break;
            }
          }
          case 58: {
            // pLiteral
            clearPredicateOtherPLiteral();
            initPLiteral();
            ProtoMessage.mergeDelimitedFrom(pLiteral, input);
            bitField0_ |= 0x00000040;
            tag = input.readTag();
            if (tag != 66) {
              break;
            }
          }
          case 66: {
            // pTripleTerm
            clearPredicateOtherPTripleTerm();
            initPTripleTerm();
            ProtoMessage.mergeDelimitedFrom(pTripleTerm, input);
            bitField0_ |= 0x00000080;
            tag = input.readTag();
            if (tag != 74) {
              break;
            }
          }
          case 74: {
            // oIri
            clearObjectOtherOIri();
            initOIri();
            ProtoMessage.mergeDelimitedFrom(oIri, input);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 82) {
              break;
            }
          }
          case 82: {
            // oBnode
            clearObjectOtherOBnode();
            initOBnode();
            oBnode = input.readStringRequireUtf8();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 90) {
              break;
            }
          }
          case 90: {
            // oLiteral
            clearObjectOtherOLiteral();
            initOLiteral();
            ProtoMessage.mergeDelimitedFrom(oLiteral, input);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 98) {
              break;
            }
          }
          case 98: {
            // oTripleTerm
            clearObjectOtherOTripleTerm();
            initOTripleTerm();
            ProtoMessage.mergeDelimitedFrom(oTripleTerm, input);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public RdfTriple clone() {
      return new RdfTriple().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static RdfTriple parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new RdfTriple(), data).checkInitialized();
    }

    public static RdfTriple parseFrom(final CodedInputStream input) throws IOException {
      return ProtoMessage.mergeFrom(new RdfTriple(), input).checkInitialized();
    }

    /**
     * @return factory for creating RdfTriple messages
     */
    public static MessageFactory<RdfTriple> getFactory() {
      return RdfTripleFactory.INSTANCE;
    }

    private enum RdfTripleFactory implements MessageFactory<RdfTriple> {
      INSTANCE;

      @Override
      public RdfTriple create() {
        return RdfTriple.newInstance();
      }
    }
  }

  /**
   * Protobuf type {@code RdfQuad}
   */
  public static final class RdfQuad extends ProtoMessage<RdfQuad> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri s_iri = 1;</code>
     */
    private RdfIri sIri = null;

    /**
     * <code>optional string s_bnode = 2;</code>
     */
    private String sBnode = null;

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral s_literal = 3;</code>
     */
    private RdfLiteral sLiteral = null;

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple s_triple_term = 4;</code>
     */
    private RdfTriple sTripleTerm = null;

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri p_iri = 5;</code>
     */
    private RdfIri pIri = null;

    /**
     * <code>optional string p_bnode = 6;</code>
     */
    private String pBnode = null;

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral p_literal = 7;</code>
     */
    private RdfLiteral pLiteral = null;

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple p_triple_term = 8;</code>
     */
    private RdfTriple pTripleTerm = null;

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri o_iri = 9;</code>
     */
    private RdfIri oIri = null;

    /**
     * <code>optional string o_bnode = 10;</code>
     */
    private String oBnode = null;

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral o_literal = 11;</code>
     */
    private RdfLiteral oLiteral = null;

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple o_triple_term = 12;</code>
     */
    private RdfTriple oTripleTerm = null;

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri g_iri = 13;</code>
     */
    private RdfIri gIri = null;

    /**
     * <code>optional string g_bnode = 14;</code>
     */
    private String gBnode = null;

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfDefaultGraph g_default_graph = 15;</code>
     */
    private RdfDefaultGraph gDefaultGraph = null;

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral g_literal = 16;</code>
     */
    private RdfLiteral gLiteral = null;

    private RdfQuad() {
    }

    /**
     * @return a new empty instance of {@code RdfQuad}
     */
    public static RdfQuad newInstance() {
      return new RdfQuad();
    }

    public boolean hasSubject() {
      return (((bitField0_ & 0x0000f000)) != 0);
    }

    public RdfQuad clearSubject() {
      if (hasSubject()) {
        clearSIri();
        clearSBnode();
        clearSLiteral();
        clearSTripleTerm();
      }
      return this;
    }

    private void clearSubjectOtherSIri() {
      if ((((bitField0_ & 0x0000e000)) != 0)) {
        clearSBnode();
        clearSLiteral();
        clearSTripleTerm();
      }
    }

    private void clearSubjectOtherSBnode() {
      if ((((bitField0_ & 0x0000d000)) != 0)) {
        clearSIri();
        clearSLiteral();
        clearSTripleTerm();
      }
    }

    private void clearSubjectOtherSLiteral() {
      if ((((bitField0_ & 0x0000b000)) != 0)) {
        clearSIri();
        clearSBnode();
        clearSTripleTerm();
      }
    }

    private void clearSubjectOtherSTripleTerm() {
      if ((((bitField0_ & 0x00007000)) != 0)) {
        clearSIri();
        clearSBnode();
        clearSLiteral();
      }
    }

    public boolean hasPredicate() {
      return (((bitField0_ & 0x00000f00)) != 0);
    }

    public RdfQuad clearPredicate() {
      if (hasPredicate()) {
        clearPIri();
        clearPBnode();
        clearPLiteral();
        clearPTripleTerm();
      }
      return this;
    }

    private void clearPredicateOtherPIri() {
      if ((((bitField0_ & 0x00000e00)) != 0)) {
        clearPBnode();
        clearPLiteral();
        clearPTripleTerm();
      }
    }

    private void clearPredicateOtherPBnode() {
      if ((((bitField0_ & 0x00000d00)) != 0)) {
        clearPIri();
        clearPLiteral();
        clearPTripleTerm();
      }
    }

    private void clearPredicateOtherPLiteral() {
      if ((((bitField0_ & 0x00000b00)) != 0)) {
        clearPIri();
        clearPBnode();
        clearPTripleTerm();
      }
    }

    private void clearPredicateOtherPTripleTerm() {
      if ((((bitField0_ & 0x00000700)) != 0)) {
        clearPIri();
        clearPBnode();
        clearPLiteral();
      }
    }

    public boolean hasObject() {
      return (((bitField0_ & 0x000000f0)) != 0);
    }

    public RdfQuad clearObject() {
      if (hasObject()) {
        clearOIri();
        clearOBnode();
        clearOLiteral();
        clearOTripleTerm();
      }
      return this;
    }

    private void clearObjectOtherOIri() {
      if ((((bitField0_ & 0x000000e0)) != 0)) {
        clearOBnode();
        clearOLiteral();
        clearOTripleTerm();
      }
    }

    private void clearObjectOtherOBnode() {
      if ((((bitField0_ & 0x000000d0)) != 0)) {
        clearOIri();
        clearOLiteral();
        clearOTripleTerm();
      }
    }

    private void clearObjectOtherOLiteral() {
      if ((((bitField0_ & 0x000000b0)) != 0)) {
        clearOIri();
        clearOBnode();
        clearOTripleTerm();
      }
    }

    private void clearObjectOtherOTripleTerm() {
      if ((((bitField0_ & 0x00000070)) != 0)) {
        clearOIri();
        clearOBnode();
        clearOLiteral();
      }
    }

    public boolean hasGraph() {
      return (((bitField0_ & 0x0000000f)) != 0);
    }

    public RdfQuad clearGraph() {
      if (hasGraph()) {
        clearGIri();
        clearGBnode();
        clearGDefaultGraph();
        clearGLiteral();
      }
      return this;
    }

    private void clearGraphOtherGIri() {
      if ((((bitField0_ & 0x0000000e)) != 0)) {
        clearGBnode();
        clearGDefaultGraph();
        clearGLiteral();
      }
    }

    private void clearGraphOtherGBnode() {
      if ((((bitField0_ & 0x0000000d)) != 0)) {
        clearGIri();
        clearGDefaultGraph();
        clearGLiteral();
      }
    }

    private void clearGraphOtherGDefaultGraph() {
      if ((((bitField0_ & 0x0000000b)) != 0)) {
        clearGIri();
        clearGBnode();
        clearGLiteral();
      }
    }

    private void clearGraphOtherGLiteral() {
      if ((((bitField0_ & 0x00000007)) != 0)) {
        clearGIri();
        clearGBnode();
        clearGDefaultGraph();
      }
    }

    private void initSIri() {
      if (sIri == null) {
        sIri = RdfIri.newInstance();
      }
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri s_iri = 1;</code>
     * @return whether the sIri field is set
     */
    public boolean hasSIri() {
      return (bitField0_ & 0x00001000) != 0;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri s_iri = 1;</code>
     * @return this
     */
    public RdfQuad clearSIri() {
      bitField0_ &= ~0x00001000;
      if (sIri != null) {
        sIri.clear();
      }
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri s_iri = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableSIri()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RdfIri getSIri() {
      initSIri();
      return sIri;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri s_iri = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RdfIri getMutableSIri() {
      clearSubjectOtherSIri();
      initSIri();
      bitField0_ |= 0x00001000;
      return sIri;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri s_iri = 1;</code>
     * @param value the sIri to set
     * @return this
     */
    public RdfQuad setSIri(final RdfIri value) {
      clearSubjectOtherSIri();
      initSIri();
      bitField0_ |= 0x00001000;
      sIri.copyFrom(value);
      return this;
    }

    private void initSBnode() {
      if (sBnode == null) {
        sBnode = "";
      }
    }

    /**
     * <code>optional string s_bnode = 2;</code>
     * @return whether the sBnode field is set
     */
    public boolean hasSBnode() {
      return (bitField0_ & 0x00002000) != 0;
    }

    /**
     * <code>optional string s_bnode = 2;</code>
     * @return this
     */
    public RdfQuad clearSBnode() {
      bitField0_ &= ~0x00002000;
      if (sBnode != null) {
        sBnode = "";
      }
      return this;
    }

    /**
     * <code>optional string s_bnode = 2;</code>
     * @return the sBnode
     */
    public String getSBnode() {
      initSBnode();
      return sBnode;
    }

    /**
     * <code>optional string s_bnode = 2;</code>
     * @param value the sBnode to set
     * @return this
     */
    public RdfQuad setSBnode(final String value) {
      clearSubjectOtherSBnode();
      initSBnode();
      bitField0_ |= 0x00002000;
      sBnode = value;
      return this;
    }

    private void initSLiteral() {
      if (sLiteral == null) {
        sLiteral = RdfLiteral.newInstance();
      }
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral s_literal = 3;</code>
     * @return whether the sLiteral field is set
     */
    public boolean hasSLiteral() {
      return (bitField0_ & 0x00004000) != 0;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral s_literal = 3;</code>
     * @return this
     */
    public RdfQuad clearSLiteral() {
      bitField0_ &= ~0x00004000;
      if (sLiteral != null) {
        sLiteral.clear();
      }
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral s_literal = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableSLiteral()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RdfLiteral getSLiteral() {
      initSLiteral();
      return sLiteral;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral s_literal = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RdfLiteral getMutableSLiteral() {
      clearSubjectOtherSLiteral();
      initSLiteral();
      bitField0_ |= 0x00004000;
      return sLiteral;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral s_literal = 3;</code>
     * @param value the sLiteral to set
     * @return this
     */
    public RdfQuad setSLiteral(final RdfLiteral value) {
      clearSubjectOtherSLiteral();
      initSLiteral();
      bitField0_ |= 0x00004000;
      sLiteral.copyFrom(value);
      return this;
    }

    private void initSTripleTerm() {
      if (sTripleTerm == null) {
        sTripleTerm = RdfTriple.newInstance();
      }
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple s_triple_term = 4;</code>
     * @return whether the sTripleTerm field is set
     */
    public boolean hasSTripleTerm() {
      return (bitField0_ & 0x00008000) != 0;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple s_triple_term = 4;</code>
     * @return this
     */
    public RdfQuad clearSTripleTerm() {
      bitField0_ &= ~0x00008000;
      if (sTripleTerm != null) {
        sTripleTerm.clear();
      }
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple s_triple_term = 4;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableSTripleTerm()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RdfTriple getSTripleTerm() {
      initSTripleTerm();
      return sTripleTerm;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple s_triple_term = 4;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RdfTriple getMutableSTripleTerm() {
      clearSubjectOtherSTripleTerm();
      initSTripleTerm();
      bitField0_ |= 0x00008000;
      return sTripleTerm;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple s_triple_term = 4;</code>
     * @param value the sTripleTerm to set
     * @return this
     */
    public RdfQuad setSTripleTerm(final RdfTriple value) {
      clearSubjectOtherSTripleTerm();
      initSTripleTerm();
      bitField0_ |= 0x00008000;
      sTripleTerm.copyFrom(value);
      return this;
    }

    private void initPIri() {
      if (pIri == null) {
        pIri = RdfIri.newInstance();
      }
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri p_iri = 5;</code>
     * @return whether the pIri field is set
     */
    public boolean hasPIri() {
      return (bitField0_ & 0x00000100) != 0;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri p_iri = 5;</code>
     * @return this
     */
    public RdfQuad clearPIri() {
      bitField0_ &= ~0x00000100;
      if (pIri != null) {
        pIri.clear();
      }
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri p_iri = 5;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutablePIri()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RdfIri getPIri() {
      initPIri();
      return pIri;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri p_iri = 5;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RdfIri getMutablePIri() {
      clearPredicateOtherPIri();
      initPIri();
      bitField0_ |= 0x00000100;
      return pIri;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri p_iri = 5;</code>
     * @param value the pIri to set
     * @return this
     */
    public RdfQuad setPIri(final RdfIri value) {
      clearPredicateOtherPIri();
      initPIri();
      bitField0_ |= 0x00000100;
      pIri.copyFrom(value);
      return this;
    }

    private void initPBnode() {
      if (pBnode == null) {
        pBnode = "";
      }
    }

    /**
     * <code>optional string p_bnode = 6;</code>
     * @return whether the pBnode field is set
     */
    public boolean hasPBnode() {
      return (bitField0_ & 0x00000200) != 0;
    }

    /**
     * <code>optional string p_bnode = 6;</code>
     * @return this
     */
    public RdfQuad clearPBnode() {
      bitField0_ &= ~0x00000200;
      if (pBnode != null) {
        pBnode = "";
      }
      return this;
    }

    /**
     * <code>optional string p_bnode = 6;</code>
     * @return the pBnode
     */
    public String getPBnode() {
      initPBnode();
      return pBnode;
    }

    /**
     * <code>optional string p_bnode = 6;</code>
     * @param value the pBnode to set
     * @return this
     */
    public RdfQuad setPBnode(final String value) {
      clearPredicateOtherPBnode();
      initPBnode();
      bitField0_ |= 0x00000200;
      pBnode = value;
      return this;
    }

    private void initPLiteral() {
      if (pLiteral == null) {
        pLiteral = RdfLiteral.newInstance();
      }
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral p_literal = 7;</code>
     * @return whether the pLiteral field is set
     */
    public boolean hasPLiteral() {
      return (bitField0_ & 0x00000400) != 0;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral p_literal = 7;</code>
     * @return this
     */
    public RdfQuad clearPLiteral() {
      bitField0_ &= ~0x00000400;
      if (pLiteral != null) {
        pLiteral.clear();
      }
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral p_literal = 7;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutablePLiteral()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RdfLiteral getPLiteral() {
      initPLiteral();
      return pLiteral;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral p_literal = 7;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RdfLiteral getMutablePLiteral() {
      clearPredicateOtherPLiteral();
      initPLiteral();
      bitField0_ |= 0x00000400;
      return pLiteral;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral p_literal = 7;</code>
     * @param value the pLiteral to set
     * @return this
     */
    public RdfQuad setPLiteral(final RdfLiteral value) {
      clearPredicateOtherPLiteral();
      initPLiteral();
      bitField0_ |= 0x00000400;
      pLiteral.copyFrom(value);
      return this;
    }

    private void initPTripleTerm() {
      if (pTripleTerm == null) {
        pTripleTerm = RdfTriple.newInstance();
      }
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple p_triple_term = 8;</code>
     * @return whether the pTripleTerm field is set
     */
    public boolean hasPTripleTerm() {
      return (bitField0_ & 0x00000800) != 0;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple p_triple_term = 8;</code>
     * @return this
     */
    public RdfQuad clearPTripleTerm() {
      bitField0_ &= ~0x00000800;
      if (pTripleTerm != null) {
        pTripleTerm.clear();
      }
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple p_triple_term = 8;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutablePTripleTerm()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RdfTriple getPTripleTerm() {
      initPTripleTerm();
      return pTripleTerm;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple p_triple_term = 8;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RdfTriple getMutablePTripleTerm() {
      clearPredicateOtherPTripleTerm();
      initPTripleTerm();
      bitField0_ |= 0x00000800;
      return pTripleTerm;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple p_triple_term = 8;</code>
     * @param value the pTripleTerm to set
     * @return this
     */
    public RdfQuad setPTripleTerm(final RdfTriple value) {
      clearPredicateOtherPTripleTerm();
      initPTripleTerm();
      bitField0_ |= 0x00000800;
      pTripleTerm.copyFrom(value);
      return this;
    }

    private void initOIri() {
      if (oIri == null) {
        oIri = RdfIri.newInstance();
      }
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri o_iri = 9;</code>
     * @return whether the oIri field is set
     */
    public boolean hasOIri() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri o_iri = 9;</code>
     * @return this
     */
    public RdfQuad clearOIri() {
      bitField0_ &= ~0x00000010;
      if (oIri != null) {
        oIri.clear();
      }
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri o_iri = 9;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableOIri()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RdfIri getOIri() {
      initOIri();
      return oIri;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri o_iri = 9;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RdfIri getMutableOIri() {
      clearObjectOtherOIri();
      initOIri();
      bitField0_ |= 0x00000010;
      return oIri;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri o_iri = 9;</code>
     * @param value the oIri to set
     * @return this
     */
    public RdfQuad setOIri(final RdfIri value) {
      clearObjectOtherOIri();
      initOIri();
      bitField0_ |= 0x00000010;
      oIri.copyFrom(value);
      return this;
    }

    private void initOBnode() {
      if (oBnode == null) {
        oBnode = "";
      }
    }

    /**
     * <code>optional string o_bnode = 10;</code>
     * @return whether the oBnode field is set
     */
    public boolean hasOBnode() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>optional string o_bnode = 10;</code>
     * @return this
     */
    public RdfQuad clearOBnode() {
      bitField0_ &= ~0x00000020;
      if (oBnode != null) {
        oBnode = "";
      }
      return this;
    }

    /**
     * <code>optional string o_bnode = 10;</code>
     * @return the oBnode
     */
    public String getOBnode() {
      initOBnode();
      return oBnode;
    }

    /**
     * <code>optional string o_bnode = 10;</code>
     * @param value the oBnode to set
     * @return this
     */
    public RdfQuad setOBnode(final String value) {
      clearObjectOtherOBnode();
      initOBnode();
      bitField0_ |= 0x00000020;
      oBnode = value;
      return this;
    }

    private void initOLiteral() {
      if (oLiteral == null) {
        oLiteral = RdfLiteral.newInstance();
      }
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral o_literal = 11;</code>
     * @return whether the oLiteral field is set
     */
    public boolean hasOLiteral() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral o_literal = 11;</code>
     * @return this
     */
    public RdfQuad clearOLiteral() {
      bitField0_ &= ~0x00000040;
      if (oLiteral != null) {
        oLiteral.clear();
      }
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral o_literal = 11;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableOLiteral()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RdfLiteral getOLiteral() {
      initOLiteral();
      return oLiteral;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral o_literal = 11;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RdfLiteral getMutableOLiteral() {
      clearObjectOtherOLiteral();
      initOLiteral();
      bitField0_ |= 0x00000040;
      return oLiteral;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral o_literal = 11;</code>
     * @param value the oLiteral to set
     * @return this
     */
    public RdfQuad setOLiteral(final RdfLiteral value) {
      clearObjectOtherOLiteral();
      initOLiteral();
      bitField0_ |= 0x00000040;
      oLiteral.copyFrom(value);
      return this;
    }

    private void initOTripleTerm() {
      if (oTripleTerm == null) {
        oTripleTerm = RdfTriple.newInstance();
      }
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple o_triple_term = 12;</code>
     * @return whether the oTripleTerm field is set
     */
    public boolean hasOTripleTerm() {
      return (bitField0_ & 0x00000080) != 0;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple o_triple_term = 12;</code>
     * @return this
     */
    public RdfQuad clearOTripleTerm() {
      bitField0_ &= ~0x00000080;
      if (oTripleTerm != null) {
        oTripleTerm.clear();
      }
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple o_triple_term = 12;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableOTripleTerm()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RdfTriple getOTripleTerm() {
      initOTripleTerm();
      return oTripleTerm;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple o_triple_term = 12;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RdfTriple getMutableOTripleTerm() {
      clearObjectOtherOTripleTerm();
      initOTripleTerm();
      bitField0_ |= 0x00000080;
      return oTripleTerm;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple o_triple_term = 12;</code>
     * @param value the oTripleTerm to set
     * @return this
     */
    public RdfQuad setOTripleTerm(final RdfTriple value) {
      clearObjectOtherOTripleTerm();
      initOTripleTerm();
      bitField0_ |= 0x00000080;
      oTripleTerm.copyFrom(value);
      return this;
    }

    private void initGIri() {
      if (gIri == null) {
        gIri = RdfIri.newInstance();
      }
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri g_iri = 13;</code>
     * @return whether the gIri field is set
     */
    public boolean hasGIri() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri g_iri = 13;</code>
     * @return this
     */
    public RdfQuad clearGIri() {
      bitField0_ &= ~0x00000001;
      if (gIri != null) {
        gIri.clear();
      }
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri g_iri = 13;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableGIri()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RdfIri getGIri() {
      initGIri();
      return gIri;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri g_iri = 13;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RdfIri getMutableGIri() {
      clearGraphOtherGIri();
      initGIri();
      bitField0_ |= 0x00000001;
      return gIri;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri g_iri = 13;</code>
     * @param value the gIri to set
     * @return this
     */
    public RdfQuad setGIri(final RdfIri value) {
      clearGraphOtherGIri();
      initGIri();
      bitField0_ |= 0x00000001;
      gIri.copyFrom(value);
      return this;
    }

    private void initGBnode() {
      if (gBnode == null) {
        gBnode = "";
      }
    }

    /**
     * <code>optional string g_bnode = 14;</code>
     * @return whether the gBnode field is set
     */
    public boolean hasGBnode() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional string g_bnode = 14;</code>
     * @return this
     */
    public RdfQuad clearGBnode() {
      bitField0_ &= ~0x00000002;
      if (gBnode != null) {
        gBnode = "";
      }
      return this;
    }

    /**
     * <code>optional string g_bnode = 14;</code>
     * @return the gBnode
     */
    public String getGBnode() {
      initGBnode();
      return gBnode;
    }

    /**
     * <code>optional string g_bnode = 14;</code>
     * @param value the gBnode to set
     * @return this
     */
    public RdfQuad setGBnode(final String value) {
      clearGraphOtherGBnode();
      initGBnode();
      bitField0_ |= 0x00000002;
      gBnode = value;
      return this;
    }

    private void initGDefaultGraph() {
      if (gDefaultGraph == null) {
        gDefaultGraph = RdfDefaultGraph.newInstance();
      }
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfDefaultGraph g_default_graph = 15;</code>
     * @return whether the gDefaultGraph field is set
     */
    public boolean hasGDefaultGraph() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfDefaultGraph g_default_graph = 15;</code>
     * @return this
     */
    public RdfQuad clearGDefaultGraph() {
      bitField0_ &= ~0x00000004;
      if (gDefaultGraph != null) {
        gDefaultGraph.clear();
      }
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfDefaultGraph g_default_graph = 15;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableGDefaultGraph()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RdfDefaultGraph getGDefaultGraph() {
      initGDefaultGraph();
      return gDefaultGraph;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfDefaultGraph g_default_graph = 15;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RdfDefaultGraph getMutableGDefaultGraph() {
      clearGraphOtherGDefaultGraph();
      initGDefaultGraph();
      bitField0_ |= 0x00000004;
      return gDefaultGraph;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfDefaultGraph g_default_graph = 15;</code>
     * @param value the gDefaultGraph to set
     * @return this
     */
    public RdfQuad setGDefaultGraph(final RdfDefaultGraph value) {
      clearGraphOtherGDefaultGraph();
      initGDefaultGraph();
      bitField0_ |= 0x00000004;
      gDefaultGraph.copyFrom(value);
      return this;
    }

    private void initGLiteral() {
      if (gLiteral == null) {
        gLiteral = RdfLiteral.newInstance();
      }
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral g_literal = 16;</code>
     * @return whether the gLiteral field is set
     */
    public boolean hasGLiteral() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral g_literal = 16;</code>
     * @return this
     */
    public RdfQuad clearGLiteral() {
      bitField0_ &= ~0x00000008;
      if (gLiteral != null) {
        gLiteral.clear();
      }
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral g_literal = 16;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableGLiteral()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RdfLiteral getGLiteral() {
      initGLiteral();
      return gLiteral;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral g_literal = 16;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RdfLiteral getMutableGLiteral() {
      clearGraphOtherGLiteral();
      initGLiteral();
      bitField0_ |= 0x00000008;
      return gLiteral;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral g_literal = 16;</code>
     * @param value the gLiteral to set
     * @return this
     */
    public RdfQuad setGLiteral(final RdfLiteral value) {
      clearGraphOtherGLiteral();
      initGLiteral();
      bitField0_ |= 0x00000008;
      gLiteral.copyFrom(value);
      return this;
    }

    @Override
    public RdfQuad copyFrom(final RdfQuad other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        if (other.hasSIri()) {
          initSIri();
          sIri.copyFrom(other.sIri);
        } else {
          clearSIri();
        }
        if (other.hasSBnode()) {
          initSBnode();
          sBnode = other.sBnode;
        } else {
          clearSBnode();
        }
        if (other.hasSLiteral()) {
          initSLiteral();
          sLiteral.copyFrom(other.sLiteral);
        } else {
          clearSLiteral();
        }
        if (other.hasSTripleTerm()) {
          initSTripleTerm();
          sTripleTerm.copyFrom(other.sTripleTerm);
        } else {
          clearSTripleTerm();
        }
        if (other.hasPIri()) {
          initPIri();
          pIri.copyFrom(other.pIri);
        } else {
          clearPIri();
        }
        if (other.hasPBnode()) {
          initPBnode();
          pBnode = other.pBnode;
        } else {
          clearPBnode();
        }
        if (other.hasPLiteral()) {
          initPLiteral();
          pLiteral.copyFrom(other.pLiteral);
        } else {
          clearPLiteral();
        }
        if (other.hasPTripleTerm()) {
          initPTripleTerm();
          pTripleTerm.copyFrom(other.pTripleTerm);
        } else {
          clearPTripleTerm();
        }
        if (other.hasOIri()) {
          initOIri();
          oIri.copyFrom(other.oIri);
        } else {
          clearOIri();
        }
        if (other.hasOBnode()) {
          initOBnode();
          oBnode = other.oBnode;
        } else {
          clearOBnode();
        }
        if (other.hasOLiteral()) {
          initOLiteral();
          oLiteral.copyFrom(other.oLiteral);
        } else {
          clearOLiteral();
        }
        if (other.hasOTripleTerm()) {
          initOTripleTerm();
          oTripleTerm.copyFrom(other.oTripleTerm);
        } else {
          clearOTripleTerm();
        }
        if (other.hasGIri()) {
          initGIri();
          gIri.copyFrom(other.gIri);
        } else {
          clearGIri();
        }
        if (other.hasGBnode()) {
          initGBnode();
          gBnode = other.gBnode;
        } else {
          clearGBnode();
        }
        if (other.hasGDefaultGraph()) {
          initGDefaultGraph();
          gDefaultGraph.copyFrom(other.gDefaultGraph);
        } else {
          clearGDefaultGraph();
        }
        if (other.hasGLiteral()) {
          initGLiteral();
          gLiteral.copyFrom(other.gLiteral);
        } else {
          clearGLiteral();
        }
      }
      return this;
    }

    @Override
    public RdfQuad mergeFrom(final RdfQuad other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasSIri()) {
        getMutableSIri().mergeFrom(other.sIri);
      }
      if (other.hasSBnode()) {
        sBnode = other.sBnode;
      }
      if (other.hasSLiteral()) {
        getMutableSLiteral().mergeFrom(other.sLiteral);
      }
      if (other.hasSTripleTerm()) {
        getMutableSTripleTerm().mergeFrom(other.sTripleTerm);
      }
      if (other.hasPIri()) {
        getMutablePIri().mergeFrom(other.pIri);
      }
      if (other.hasPBnode()) {
        pBnode = other.pBnode;
      }
      if (other.hasPLiteral()) {
        getMutablePLiteral().mergeFrom(other.pLiteral);
      }
      if (other.hasPTripleTerm()) {
        getMutablePTripleTerm().mergeFrom(other.pTripleTerm);
      }
      if (other.hasOIri()) {
        getMutableOIri().mergeFrom(other.oIri);
      }
      if (other.hasOBnode()) {
        oBnode = other.oBnode;
      }
      if (other.hasOLiteral()) {
        getMutableOLiteral().mergeFrom(other.oLiteral);
      }
      if (other.hasOTripleTerm()) {
        getMutableOTripleTerm().mergeFrom(other.oTripleTerm);
      }
      if (other.hasGIri()) {
        getMutableGIri().mergeFrom(other.gIri);
      }
      if (other.hasGBnode()) {
        gBnode = other.gBnode;
      }
      if (other.hasGDefaultGraph()) {
        getMutableGDefaultGraph().mergeFrom(other.gDefaultGraph);
      }
      if (other.hasGLiteral()) {
        getMutableGLiteral().mergeFrom(other.gLiteral);
      }
      return this;
    }

    @Override
    public RdfQuad clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (sIri != null) {
        sIri.clear();
      }
      if (sBnode != null) {
        sBnode = "";
      }
      if (sLiteral != null) {
        sLiteral.clear();
      }
      if (sTripleTerm != null) {
        sTripleTerm.clear();
      }
      if (pIri != null) {
        pIri.clear();
      }
      if (pBnode != null) {
        pBnode = "";
      }
      if (pLiteral != null) {
        pLiteral.clear();
      }
      if (pTripleTerm != null) {
        pTripleTerm.clear();
      }
      if (oIri != null) {
        oIri.clear();
      }
      if (oBnode != null) {
        oBnode = "";
      }
      if (oLiteral != null) {
        oLiteral.clear();
      }
      if (oTripleTerm != null) {
        oTripleTerm.clear();
      }
      if (gIri != null) {
        gIri.clear();
      }
      if (gBnode != null) {
        gBnode = "";
      }
      if (gDefaultGraph != null) {
        gDefaultGraph.clear();
      }
      if (gLiteral != null) {
        gLiteral.clear();
      }
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof RdfQuad)) {
        return false;
      }
      RdfQuad other = (RdfQuad) o;
      return bitField0_ == other.bitField0_
        && (!hasSIri() || sIri.equals(other.sIri))
        && (!hasSBnode() || sBnode.equals(other.sBnode))
        && (!hasSLiteral() || sLiteral.equals(other.sLiteral))
        && (!hasSTripleTerm() || sTripleTerm.equals(other.sTripleTerm))
        && (!hasPIri() || pIri.equals(other.pIri))
        && (!hasPBnode() || pBnode.equals(other.pBnode))
        && (!hasPLiteral() || pLiteral.equals(other.pLiteral))
        && (!hasPTripleTerm() || pTripleTerm.equals(other.pTripleTerm))
        && (!hasOIri() || oIri.equals(other.oIri))
        && (!hasOBnode() || oBnode.equals(other.oBnode))
        && (!hasOLiteral() || oLiteral.equals(other.oLiteral))
        && (!hasOTripleTerm() || oTripleTerm.equals(other.oTripleTerm))
        && (!hasGIri() || gIri.equals(other.gIri))
        && (!hasGBnode() || gBnode.equals(other.gBnode))
        && (!hasGDefaultGraph() || gDefaultGraph.equals(other.gDefaultGraph))
        && (!hasGLiteral() || gLiteral.equals(other.gLiteral));
    }

    @Override
    public void writeTo(final CodedOutputStream output) throws IOException {
      if ((bitField0_ & 0x00001000) != 0) {
        output.writeRawByte((byte) 10);
        output.writeUInt32NoTag(sIri.getCachedSize());
        sIri.writeTo(output);
      }
      if ((bitField0_ & 0x00002000) != 0) {
        output.writeRawByte((byte) 18);
        output.writeStringNoTag(sBnode);
      }
      if ((bitField0_ & 0x00004000) != 0) {
        output.writeRawByte((byte) 26);
        output.writeUInt32NoTag(sLiteral.getCachedSize());
        sLiteral.writeTo(output);
      }
      if ((bitField0_ & 0x00008000) != 0) {
        output.writeRawByte((byte) 34);
        output.writeUInt32NoTag(sTripleTerm.getCachedSize());
        sTripleTerm.writeTo(output);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        output.writeRawByte((byte) 42);
        output.writeUInt32NoTag(pIri.getCachedSize());
        pIri.writeTo(output);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        output.writeRawByte((byte) 50);
        output.writeStringNoTag(pBnode);
      }
      if ((bitField0_ & 0x00000400) != 0) {
        output.writeRawByte((byte) 58);
        output.writeUInt32NoTag(pLiteral.getCachedSize());
        pLiteral.writeTo(output);
      }
      if ((bitField0_ & 0x00000800) != 0) {
        output.writeRawByte((byte) 66);
        output.writeUInt32NoTag(pTripleTerm.getCachedSize());
        pTripleTerm.writeTo(output);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawByte((byte) 74);
        output.writeUInt32NoTag(oIri.getCachedSize());
        oIri.writeTo(output);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRawByte((byte) 82);
        output.writeStringNoTag(oBnode);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeRawByte((byte) 90);
        output.writeUInt32NoTag(oLiteral.getCachedSize());
        oLiteral.writeTo(output);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeRawByte((byte) 98);
        output.writeUInt32NoTag(oTripleTerm.getCachedSize());
        oTripleTerm.writeTo(output);
      }
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 106);
        output.writeUInt32NoTag(gIri.getCachedSize());
        gIri.writeTo(output);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 114);
        output.writeStringNoTag(gBnode);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 122);
        output.writeUInt32NoTag(gDefaultGraph.getCachedSize());
        gDefaultGraph.writeTo(output);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 130);
        output.writeRawByte((byte) 1);
        output.writeUInt32NoTag(gLiteral.getCachedSize());
        gLiteral.writeTo(output);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00001000) != 0) {
        final int dataSize = sIri.getSerializedSize();
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
      }
      if ((bitField0_ & 0x00002000) != 0) {
        size += 1 + CodedOutputStream.computeStringSizeNoTag(sBnode);
      }
      if ((bitField0_ & 0x00004000) != 0) {
        final int dataSize = sLiteral.getSerializedSize();
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
      }
      if ((bitField0_ & 0x00008000) != 0) {
        final int dataSize = sTripleTerm.getSerializedSize();
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
      }
      if ((bitField0_ & 0x00000100) != 0) {
        final int dataSize = pIri.getSerializedSize();
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
      }
      if ((bitField0_ & 0x00000200) != 0) {
        size += 1 + CodedOutputStream.computeStringSizeNoTag(pBnode);
      }
      if ((bitField0_ & 0x00000400) != 0) {
        final int dataSize = pLiteral.getSerializedSize();
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
      }
      if ((bitField0_ & 0x00000800) != 0) {
        final int dataSize = pTripleTerm.getSerializedSize();
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
      }
      if ((bitField0_ & 0x00000010) != 0) {
        final int dataSize = oIri.getSerializedSize();
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += 1 + CodedOutputStream.computeStringSizeNoTag(oBnode);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        final int dataSize = oLiteral.getSerializedSize();
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
      }
      if ((bitField0_ & 0x00000080) != 0) {
        final int dataSize = oTripleTerm.getSerializedSize();
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
      }
      if ((bitField0_ & 0x00000001) != 0) {
        final int dataSize = gIri.getSerializedSize();
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + CodedOutputStream.computeStringSizeNoTag(gBnode);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        final int dataSize = gDefaultGraph.getSerializedSize();
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
      }
      if ((bitField0_ & 0x00000008) != 0) {
        final int dataSize = gLiteral.getSerializedSize();
        size += 2 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public RdfQuad mergeFrom(final CodedInputStream input) throws IOException {
      // Enabled Fall-Through Optimization (Quickbuf)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 10: {
            // sIri
            clearSubjectOtherSIri();
            initSIri();
            ProtoMessage.mergeDelimitedFrom(sIri, input);
            bitField0_ |= 0x00001000;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // sBnode
            clearSubjectOtherSBnode();
            initSBnode();
            sBnode = input.readStringRequireUtf8();
            bitField0_ |= 0x00002000;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // sLiteral
            clearSubjectOtherSLiteral();
            initSLiteral();
            ProtoMessage.mergeDelimitedFrom(sLiteral, input);
            bitField0_ |= 0x00004000;
            tag = input.readTag();
            if (tag != 34) {
              break;
            }
          }
          case 34: {
            // sTripleTerm
            clearSubjectOtherSTripleTerm();
            initSTripleTerm();
            ProtoMessage.mergeDelimitedFrom(sTripleTerm, input);
            bitField0_ |= 0x00008000;
            tag = input.readTag();
            if (tag != 42) {
              break;
            }
          }
          case 42: {
            // pIri
            clearPredicateOtherPIri();
            initPIri();
            ProtoMessage.mergeDelimitedFrom(pIri, input);
            bitField0_ |= 0x00000100;
            tag = input.readTag();
            if (tag != 50) {
              break;
            }
          }
          case 50: {
            // pBnode
            clearPredicateOtherPBnode();
            initPBnode();
            pBnode = input.readStringRequireUtf8();
            bitField0_ |= 0x00000200;
            tag = input.readTag();
            if (tag != 58) {
              break;
            }
          }
          case 58: {
            // pLiteral
            clearPredicateOtherPLiteral();
            initPLiteral();
            ProtoMessage.mergeDelimitedFrom(pLiteral, input);
            bitField0_ |= 0x00000400;
            tag = input.readTag();
            if (tag != 66) {
              break;
            }
          }
          case 66: {
            // pTripleTerm
            clearPredicateOtherPTripleTerm();
            initPTripleTerm();
            ProtoMessage.mergeDelimitedFrom(pTripleTerm, input);
            bitField0_ |= 0x00000800;
            tag = input.readTag();
            if (tag != 74) {
              break;
            }
          }
          case 74: {
            // oIri
            clearObjectOtherOIri();
            initOIri();
            ProtoMessage.mergeDelimitedFrom(oIri, input);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 82) {
              break;
            }
          }
          case 82: {
            // oBnode
            clearObjectOtherOBnode();
            initOBnode();
            oBnode = input.readStringRequireUtf8();
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 90) {
              break;
            }
          }
          case 90: {
            // oLiteral
            clearObjectOtherOLiteral();
            initOLiteral();
            ProtoMessage.mergeDelimitedFrom(oLiteral, input);
            bitField0_ |= 0x00000040;
            tag = input.readTag();
            if (tag != 98) {
              break;
            }
          }
          case 98: {
            // oTripleTerm
            clearObjectOtherOTripleTerm();
            initOTripleTerm();
            ProtoMessage.mergeDelimitedFrom(oTripleTerm, input);
            bitField0_ |= 0x00000080;
            tag = input.readTag();
            if (tag != 106) {
              break;
            }
          }
          case 106: {
            // gIri
            clearGraphOtherGIri();
            initGIri();
            ProtoMessage.mergeDelimitedFrom(gIri, input);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 114) {
              break;
            }
          }
          case 114: {
            // gBnode
            clearGraphOtherGBnode();
            initGBnode();
            gBnode = input.readStringRequireUtf8();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 122) {
              break;
            }
          }
          case 122: {
            // gDefaultGraph
            clearGraphOtherGDefaultGraph();
            initGDefaultGraph();
            ProtoMessage.mergeDelimitedFrom(gDefaultGraph, input);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 130) {
              break;
            }
          }
          case 130: {
            // gLiteral
            clearGraphOtherGLiteral();
            initGLiteral();
            ProtoMessage.mergeDelimitedFrom(gLiteral, input);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public RdfQuad clone() {
      return new RdfQuad().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static RdfQuad parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new RdfQuad(), data).checkInitialized();
    }

    public static RdfQuad parseFrom(final CodedInputStream input) throws IOException {
      return ProtoMessage.mergeFrom(new RdfQuad(), input).checkInitialized();
    }

    /**
     * @return factory for creating RdfQuad messages
     */
    public static MessageFactory<RdfQuad> getFactory() {
      return RdfQuadFactory.INSTANCE;
    }

    private enum RdfQuadFactory implements MessageFactory<RdfQuad> {
      INSTANCE;

      @Override
      public RdfQuad create() {
        return RdfQuad.newInstance();
      }
    }
  }

  /**
   * Protobuf type {@code RdfGraphStart}
   */
  public static final class RdfGraphStart extends ProtoMessage<RdfGraphStart> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri g_iri = 1;</code>
     */
    private RdfIri gIri = null;

    /**
     * <code>optional string g_bnode = 2;</code>
     */
    private String gBnode = null;

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfDefaultGraph g_default_graph = 3;</code>
     */
    private RdfDefaultGraph gDefaultGraph = null;

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral g_literal = 4;</code>
     */
    private RdfLiteral gLiteral = null;

    private RdfGraphStart() {
    }

    /**
     * @return a new empty instance of {@code RdfGraphStart}
     */
    public static RdfGraphStart newInstance() {
      return new RdfGraphStart();
    }

    public boolean hasGraph() {
      return (((bitField0_ & 0x0000000f)) != 0);
    }

    public RdfGraphStart clearGraph() {
      if (hasGraph()) {
        clearGIri();
        clearGBnode();
        clearGDefaultGraph();
        clearGLiteral();
      }
      return this;
    }

    private void clearGraphOtherGIri() {
      if ((((bitField0_ & 0x0000000e)) != 0)) {
        clearGBnode();
        clearGDefaultGraph();
        clearGLiteral();
      }
    }

    private void clearGraphOtherGBnode() {
      if ((((bitField0_ & 0x0000000d)) != 0)) {
        clearGIri();
        clearGDefaultGraph();
        clearGLiteral();
      }
    }

    private void clearGraphOtherGDefaultGraph() {
      if ((((bitField0_ & 0x0000000b)) != 0)) {
        clearGIri();
        clearGBnode();
        clearGLiteral();
      }
    }

    private void clearGraphOtherGLiteral() {
      if ((((bitField0_ & 0x00000007)) != 0)) {
        clearGIri();
        clearGBnode();
        clearGDefaultGraph();
      }
    }

    private void initGIri() {
      if (gIri == null) {
        gIri = RdfIri.newInstance();
      }
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri g_iri = 1;</code>
     * @return whether the gIri field is set
     */
    public boolean hasGIri() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri g_iri = 1;</code>
     * @return this
     */
    public RdfGraphStart clearGIri() {
      bitField0_ &= ~0x00000001;
      if (gIri != null) {
        gIri.clear();
      }
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri g_iri = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableGIri()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RdfIri getGIri() {
      initGIri();
      return gIri;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri g_iri = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RdfIri getMutableGIri() {
      clearGraphOtherGIri();
      initGIri();
      bitField0_ |= 0x00000001;
      return gIri;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri g_iri = 1;</code>
     * @param value the gIri to set
     * @return this
     */
    public RdfGraphStart setGIri(final RdfIri value) {
      clearGraphOtherGIri();
      initGIri();
      bitField0_ |= 0x00000001;
      gIri.copyFrom(value);
      return this;
    }

    private void initGBnode() {
      if (gBnode == null) {
        gBnode = "";
      }
    }

    /**
     * <code>optional string g_bnode = 2;</code>
     * @return whether the gBnode field is set
     */
    public boolean hasGBnode() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional string g_bnode = 2;</code>
     * @return this
     */
    public RdfGraphStart clearGBnode() {
      bitField0_ &= ~0x00000002;
      if (gBnode != null) {
        gBnode = "";
      }
      return this;
    }

    /**
     * <code>optional string g_bnode = 2;</code>
     * @return the gBnode
     */
    public String getGBnode() {
      initGBnode();
      return gBnode;
    }

    /**
     * <code>optional string g_bnode = 2;</code>
     * @param value the gBnode to set
     * @return this
     */
    public RdfGraphStart setGBnode(final String value) {
      clearGraphOtherGBnode();
      initGBnode();
      bitField0_ |= 0x00000002;
      gBnode = value;
      return this;
    }

    private void initGDefaultGraph() {
      if (gDefaultGraph == null) {
        gDefaultGraph = RdfDefaultGraph.newInstance();
      }
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfDefaultGraph g_default_graph = 3;</code>
     * @return whether the gDefaultGraph field is set
     */
    public boolean hasGDefaultGraph() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfDefaultGraph g_default_graph = 3;</code>
     * @return this
     */
    public RdfGraphStart clearGDefaultGraph() {
      bitField0_ &= ~0x00000004;
      if (gDefaultGraph != null) {
        gDefaultGraph.clear();
      }
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfDefaultGraph g_default_graph = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableGDefaultGraph()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RdfDefaultGraph getGDefaultGraph() {
      initGDefaultGraph();
      return gDefaultGraph;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfDefaultGraph g_default_graph = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RdfDefaultGraph getMutableGDefaultGraph() {
      clearGraphOtherGDefaultGraph();
      initGDefaultGraph();
      bitField0_ |= 0x00000004;
      return gDefaultGraph;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfDefaultGraph g_default_graph = 3;</code>
     * @param value the gDefaultGraph to set
     * @return this
     */
    public RdfGraphStart setGDefaultGraph(final RdfDefaultGraph value) {
      clearGraphOtherGDefaultGraph();
      initGDefaultGraph();
      bitField0_ |= 0x00000004;
      gDefaultGraph.copyFrom(value);
      return this;
    }

    private void initGLiteral() {
      if (gLiteral == null) {
        gLiteral = RdfLiteral.newInstance();
      }
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral g_literal = 4;</code>
     * @return whether the gLiteral field is set
     */
    public boolean hasGLiteral() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral g_literal = 4;</code>
     * @return this
     */
    public RdfGraphStart clearGLiteral() {
      bitField0_ &= ~0x00000008;
      if (gLiteral != null) {
        gLiteral.clear();
      }
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral g_literal = 4;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableGLiteral()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RdfLiteral getGLiteral() {
      initGLiteral();
      return gLiteral;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral g_literal = 4;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RdfLiteral getMutableGLiteral() {
      clearGraphOtherGLiteral();
      initGLiteral();
      bitField0_ |= 0x00000008;
      return gLiteral;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral g_literal = 4;</code>
     * @param value the gLiteral to set
     * @return this
     */
    public RdfGraphStart setGLiteral(final RdfLiteral value) {
      clearGraphOtherGLiteral();
      initGLiteral();
      bitField0_ |= 0x00000008;
      gLiteral.copyFrom(value);
      return this;
    }

    @Override
    public RdfGraphStart copyFrom(final RdfGraphStart other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        if (other.hasGIri()) {
          initGIri();
          gIri.copyFrom(other.gIri);
        } else {
          clearGIri();
        }
        if (other.hasGBnode()) {
          initGBnode();
          gBnode = other.gBnode;
        } else {
          clearGBnode();
        }
        if (other.hasGDefaultGraph()) {
          initGDefaultGraph();
          gDefaultGraph.copyFrom(other.gDefaultGraph);
        } else {
          clearGDefaultGraph();
        }
        if (other.hasGLiteral()) {
          initGLiteral();
          gLiteral.copyFrom(other.gLiteral);
        } else {
          clearGLiteral();
        }
      }
      return this;
    }

    @Override
    public RdfGraphStart mergeFrom(final RdfGraphStart other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasGIri()) {
        getMutableGIri().mergeFrom(other.gIri);
      }
      if (other.hasGBnode()) {
        gBnode = other.gBnode;
      }
      if (other.hasGDefaultGraph()) {
        getMutableGDefaultGraph().mergeFrom(other.gDefaultGraph);
      }
      if (other.hasGLiteral()) {
        getMutableGLiteral().mergeFrom(other.gLiteral);
      }
      return this;
    }

    @Override
    public RdfGraphStart clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (gIri != null) {
        gIri.clear();
      }
      if (gBnode != null) {
        gBnode = "";
      }
      if (gDefaultGraph != null) {
        gDefaultGraph.clear();
      }
      if (gLiteral != null) {
        gLiteral.clear();
      }
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof RdfGraphStart)) {
        return false;
      }
      RdfGraphStart other = (RdfGraphStart) o;
      return bitField0_ == other.bitField0_
        && (!hasGIri() || gIri.equals(other.gIri))
        && (!hasGBnode() || gBnode.equals(other.gBnode))
        && (!hasGDefaultGraph() || gDefaultGraph.equals(other.gDefaultGraph))
        && (!hasGLiteral() || gLiteral.equals(other.gLiteral));
    }

    @Override
    public void writeTo(final CodedOutputStream output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 10);
        output.writeUInt32NoTag(gIri.getCachedSize());
        gIri.writeTo(output);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 18);
        output.writeStringNoTag(gBnode);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 26);
        output.writeUInt32NoTag(gDefaultGraph.getCachedSize());
        gDefaultGraph.writeTo(output);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 34);
        output.writeUInt32NoTag(gLiteral.getCachedSize());
        gLiteral.writeTo(output);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        final int dataSize = gIri.getSerializedSize();
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + CodedOutputStream.computeStringSizeNoTag(gBnode);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        final int dataSize = gDefaultGraph.getSerializedSize();
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
      }
      if ((bitField0_ & 0x00000008) != 0) {
        final int dataSize = gLiteral.getSerializedSize();
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public RdfGraphStart mergeFrom(final CodedInputStream input) throws IOException {
      // Enabled Fall-Through Optimization (Quickbuf)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 10: {
            // gIri
            clearGraphOtherGIri();
            initGIri();
            ProtoMessage.mergeDelimitedFrom(gIri, input);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // gBnode
            clearGraphOtherGBnode();
            initGBnode();
            gBnode = input.readStringRequireUtf8();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // gDefaultGraph
            clearGraphOtherGDefaultGraph();
            initGDefaultGraph();
            ProtoMessage.mergeDelimitedFrom(gDefaultGraph, input);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 34) {
              break;
            }
          }
          case 34: {
            // gLiteral
            clearGraphOtherGLiteral();
            initGLiteral();
            ProtoMessage.mergeDelimitedFrom(gLiteral, input);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public RdfGraphStart clone() {
      return new RdfGraphStart().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static RdfGraphStart parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new RdfGraphStart(), data).checkInitialized();
    }

    public static RdfGraphStart parseFrom(final CodedInputStream input) throws IOException {
      return ProtoMessage.mergeFrom(new RdfGraphStart(), input).checkInitialized();
    }

    /**
     * @return factory for creating RdfGraphStart messages
     */
    public static MessageFactory<RdfGraphStart> getFactory() {
      return RdfGraphStartFactory.INSTANCE;
    }

    private enum RdfGraphStartFactory implements MessageFactory<RdfGraphStart> {
      INSTANCE;

      @Override
      public RdfGraphStart create() {
        return RdfGraphStart.newInstance();
      }
    }
  }

  /**
   * Protobuf type {@code RdfGraphEnd}
   */
  public static final class RdfGraphEnd extends ProtoMessage<RdfGraphEnd> implements Cloneable {
    private static final long serialVersionUID = 0L;

    private RdfGraphEnd() {
    }

    /**
     * @return a new empty instance of {@code RdfGraphEnd}
     */
    public static RdfGraphEnd newInstance() {
      return new RdfGraphEnd();
    }

    @Override
    public RdfGraphEnd copyFrom(final RdfGraphEnd other) {
      cachedSize = other.cachedSize;
      return this;
    }

    @Override
    public RdfGraphEnd mergeFrom(final RdfGraphEnd other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      return this;
    }

    @Override
    public RdfGraphEnd clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof RdfGraphEnd)) {
        return false;
      }
      RdfGraphEnd other = (RdfGraphEnd) o;
      return true;
    }

    @Override
    public void writeTo(final CodedOutputStream output) throws IOException {
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public RdfGraphEnd mergeFrom(final CodedInputStream input) throws IOException {
      // Enabled Fall-Through Optimization (Quickbuf)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public RdfGraphEnd clone() {
      return new RdfGraphEnd().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static RdfGraphEnd parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new RdfGraphEnd(), data).checkInitialized();
    }

    public static RdfGraphEnd parseFrom(final CodedInputStream input) throws IOException {
      return ProtoMessage.mergeFrom(new RdfGraphEnd(), input).checkInitialized();
    }

    /**
     * @return factory for creating RdfGraphEnd messages
     */
    public static MessageFactory<RdfGraphEnd> getFactory() {
      return RdfGraphEndFactory.INSTANCE;
    }

    private enum RdfGraphEndFactory implements MessageFactory<RdfGraphEnd> {
      INSTANCE;

      @Override
      public RdfGraphEnd create() {
        return RdfGraphEnd.newInstance();
      }
    }
  }

  /**
   * Protobuf type {@code RdfNamespaceDeclaration}
   */
  public static final class RdfNamespaceDeclaration extends ProtoMessage<RdfNamespaceDeclaration> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional string name = 1;</code>
     */
    private String name = null;

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri value = 2;</code>
     */
    private RdfIri value_ = null;

    private RdfNamespaceDeclaration() {
    }

    /**
     * @return a new empty instance of {@code RdfNamespaceDeclaration}
     */
    public static RdfNamespaceDeclaration newInstance() {
      return new RdfNamespaceDeclaration();
    }

    private void initName() {
      if (name == null) {
        name = "";
      }
    }

    /**
     * <code>optional string name = 1;</code>
     * @return whether the name field is set
     */
    public boolean hasName() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional string name = 1;</code>
     * @return this
     */
    public RdfNamespaceDeclaration clearName() {
      bitField0_ &= ~0x00000001;
      if (name != null) {
        name = "";
      }
      return this;
    }

    /**
     * <code>optional string name = 1;</code>
     * @return the name
     */
    public String getName() {
      initName();
      return name;
    }

    /**
     * <code>optional string name = 1;</code>
     * @param value the name to set
     * @return this
     */
    public RdfNamespaceDeclaration setName(final String value) {
      initName();
      bitField0_ |= 0x00000001;
      name = value;
      return this;
    }

    private void initValue() {
      if (value_ == null) {
        value_ = RdfIri.newInstance();
      }
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri value = 2;</code>
     * @return whether the value_ field is set
     */
    public boolean hasValue() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri value = 2;</code>
     * @return this
     */
    public RdfNamespaceDeclaration clearValue() {
      bitField0_ &= ~0x00000002;
      if (value_ != null) {
        value_.clear();
      }
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri value = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableValue()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RdfIri getValue() {
      initValue();
      return value_;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri value = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RdfIri getMutableValue() {
      initValue();
      bitField0_ |= 0x00000002;
      return value_;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri value = 2;</code>
     * @param value the value_ to set
     * @return this
     */
    public RdfNamespaceDeclaration setValue(final RdfIri value) {
      initValue();
      bitField0_ |= 0x00000002;
      value_.copyFrom(value);
      return this;
    }

    @Override
    public RdfNamespaceDeclaration copyFrom(final RdfNamespaceDeclaration other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        if (other.hasName()) {
          initName();
          name = other.name;
        } else {
          clearName();
        }
        if (other.hasValue()) {
          initValue();
          value_.copyFrom(other.value_);
        } else {
          clearValue();
        }
      }
      return this;
    }

    @Override
    public RdfNamespaceDeclaration mergeFrom(final RdfNamespaceDeclaration other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasName()) {
        name = other.name;
      }
      if (other.hasValue()) {
        getMutableValue().mergeFrom(other.value_);
      }
      return this;
    }

    @Override
    public RdfNamespaceDeclaration clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (name != null) {
        name = "";
      }
      if (value_ != null) {
        value_.clear();
      }
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof RdfNamespaceDeclaration)) {
        return false;
      }
      RdfNamespaceDeclaration other = (RdfNamespaceDeclaration) o;
      return bitField0_ == other.bitField0_
        && (!hasName() || name.equals(other.name))
        && (!hasValue() || value_.equals(other.value_));
    }

    @Override
    public void writeTo(final CodedOutputStream output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 10);
        output.writeStringNoTag(name);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 18);
        output.writeUInt32NoTag(value_.getCachedSize());
        value_.writeTo(output);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + CodedOutputStream.computeStringSizeNoTag(name);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        final int dataSize = value_.getSerializedSize();
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public RdfNamespaceDeclaration mergeFrom(final CodedInputStream input) throws IOException {
      // Enabled Fall-Through Optimization (Quickbuf)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 10: {
            // name
            initName();
            name = input.readStringRequireUtf8();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // value_
            initValue();
            ProtoMessage.mergeDelimitedFrom(value_, input);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public RdfNamespaceDeclaration clone() {
      return new RdfNamespaceDeclaration().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static RdfNamespaceDeclaration parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new RdfNamespaceDeclaration(), data).checkInitialized();
    }

    public static RdfNamespaceDeclaration parseFrom(final CodedInputStream input) throws
        IOException {
      return ProtoMessage.mergeFrom(new RdfNamespaceDeclaration(), input).checkInitialized();
    }

    /**
     * @return factory for creating RdfNamespaceDeclaration messages
     */
    public static MessageFactory<RdfNamespaceDeclaration> getFactory() {
      return RdfNamespaceDeclarationFactory.INSTANCE;
    }

    private enum RdfNamespaceDeclarationFactory implements MessageFactory<RdfNamespaceDeclaration> {
      INSTANCE;

      @Override
      public RdfNamespaceDeclaration create() {
        return RdfNamespaceDeclaration.newInstance();
      }
    }
  }

  /**
   * Protobuf type {@code RdfNameEntry}
   */
  public static final class RdfNameEntry extends ProtoMessage<RdfNameEntry> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 id = 1;</code>
     */
    private int id;

    /**
     * <code>optional string value = 2;</code>
     */
    private String value_ = null;

    private RdfNameEntry() {
    }

    /**
     * @return a new empty instance of {@code RdfNameEntry}
     */
    public static RdfNameEntry newInstance() {
      return new RdfNameEntry();
    }

    /**
     * <code>optional uint32 id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 id = 1;</code>
     * @return this
     */
    public RdfNameEntry clearId() {
      bitField0_ &= ~0x00000001;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public RdfNameEntry setId(final int value) {
      bitField0_ |= 0x00000001;
      id = value;
      return this;
    }

    private void initValue() {
      if (value_ == null) {
        value_ = "";
      }
    }

    /**
     * <code>optional string value = 2;</code>
     * @return whether the value_ field is set
     */
    public boolean hasValue() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional string value = 2;</code>
     * @return this
     */
    public RdfNameEntry clearValue() {
      bitField0_ &= ~0x00000002;
      if (value_ != null) {
        value_ = "";
      }
      return this;
    }

    /**
     * <code>optional string value = 2;</code>
     * @return the value_
     */
    public String getValue() {
      initValue();
      return value_;
    }

    /**
     * <code>optional string value = 2;</code>
     * @param value the value_ to set
     * @return this
     */
    public RdfNameEntry setValue(final String value) {
      initValue();
      bitField0_ |= 0x00000002;
      value_ = value;
      return this;
    }

    @Override
    public RdfNameEntry copyFrom(final RdfNameEntry other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        id = other.id;
        if (other.hasValue()) {
          initValue();
          value_ = other.value_;
        } else {
          clearValue();
        }
      }
      return this;
    }

    @Override
    public RdfNameEntry mergeFrom(final RdfNameEntry other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasValue()) {
        value_ = other.value_;
      }
      return this;
    }

    @Override
    public RdfNameEntry clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      id = 0;
      if (value_ != null) {
        value_ = "";
      }
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof RdfNameEntry)) {
        return false;
      }
      RdfNameEntry other = (RdfNameEntry) o;
      return bitField0_ == other.bitField0_
        && (!hasId() || id == other.id)
        && (!hasValue() || value_.equals(other.value_));
    }

    @Override
    public void writeTo(final CodedOutputStream output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 18);
        output.writeStringNoTag(value_);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + CodedOutputStream.computeStringSizeNoTag(value_);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public RdfNameEntry mergeFrom(final CodedInputStream input) throws IOException {
      // Enabled Fall-Through Optimization (Quickbuf)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // value_
            initValue();
            value_ = input.readStringRequireUtf8();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public RdfNameEntry clone() {
      return new RdfNameEntry().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static RdfNameEntry parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new RdfNameEntry(), data).checkInitialized();
    }

    public static RdfNameEntry parseFrom(final CodedInputStream input) throws IOException {
      return ProtoMessage.mergeFrom(new RdfNameEntry(), input).checkInitialized();
    }

    /**
     * @return factory for creating RdfNameEntry messages
     */
    public static MessageFactory<RdfNameEntry> getFactory() {
      return RdfNameEntryFactory.INSTANCE;
    }

    private enum RdfNameEntryFactory implements MessageFactory<RdfNameEntry> {
      INSTANCE;

      @Override
      public RdfNameEntry create() {
        return RdfNameEntry.newInstance();
      }
    }
  }

  /**
   * Protobuf type {@code RdfPrefixEntry}
   */
  public static final class RdfPrefixEntry extends ProtoMessage<RdfPrefixEntry> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 id = 1;</code>
     */
    private int id;

    /**
     * <code>optional string value = 2;</code>
     */
    private String value_ = null;

    private RdfPrefixEntry() {
    }

    /**
     * @return a new empty instance of {@code RdfPrefixEntry}
     */
    public static RdfPrefixEntry newInstance() {
      return new RdfPrefixEntry();
    }

    /**
     * <code>optional uint32 id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 id = 1;</code>
     * @return this
     */
    public RdfPrefixEntry clearId() {
      bitField0_ &= ~0x00000001;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public RdfPrefixEntry setId(final int value) {
      bitField0_ |= 0x00000001;
      id = value;
      return this;
    }

    private void initValue() {
      if (value_ == null) {
        value_ = "";
      }
    }

    /**
     * <code>optional string value = 2;</code>
     * @return whether the value_ field is set
     */
    public boolean hasValue() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional string value = 2;</code>
     * @return this
     */
    public RdfPrefixEntry clearValue() {
      bitField0_ &= ~0x00000002;
      if (value_ != null) {
        value_ = "";
      }
      return this;
    }

    /**
     * <code>optional string value = 2;</code>
     * @return the value_
     */
    public String getValue() {
      initValue();
      return value_;
    }

    /**
     * <code>optional string value = 2;</code>
     * @param value the value_ to set
     * @return this
     */
    public RdfPrefixEntry setValue(final String value) {
      initValue();
      bitField0_ |= 0x00000002;
      value_ = value;
      return this;
    }

    @Override
    public RdfPrefixEntry copyFrom(final RdfPrefixEntry other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        id = other.id;
        if (other.hasValue()) {
          initValue();
          value_ = other.value_;
        } else {
          clearValue();
        }
      }
      return this;
    }

    @Override
    public RdfPrefixEntry mergeFrom(final RdfPrefixEntry other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasValue()) {
        value_ = other.value_;
      }
      return this;
    }

    @Override
    public RdfPrefixEntry clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      id = 0;
      if (value_ != null) {
        value_ = "";
      }
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof RdfPrefixEntry)) {
        return false;
      }
      RdfPrefixEntry other = (RdfPrefixEntry) o;
      return bitField0_ == other.bitField0_
        && (!hasId() || id == other.id)
        && (!hasValue() || value_.equals(other.value_));
    }

    @Override
    public void writeTo(final CodedOutputStream output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 18);
        output.writeStringNoTag(value_);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + CodedOutputStream.computeStringSizeNoTag(value_);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public RdfPrefixEntry mergeFrom(final CodedInputStream input) throws IOException {
      // Enabled Fall-Through Optimization (Quickbuf)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // value_
            initValue();
            value_ = input.readStringRequireUtf8();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public RdfPrefixEntry clone() {
      return new RdfPrefixEntry().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static RdfPrefixEntry parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new RdfPrefixEntry(), data).checkInitialized();
    }

    public static RdfPrefixEntry parseFrom(final CodedInputStream input) throws IOException {
      return ProtoMessage.mergeFrom(new RdfPrefixEntry(), input).checkInitialized();
    }

    /**
     * @return factory for creating RdfPrefixEntry messages
     */
    public static MessageFactory<RdfPrefixEntry> getFactory() {
      return RdfPrefixEntryFactory.INSTANCE;
    }

    private enum RdfPrefixEntryFactory implements MessageFactory<RdfPrefixEntry> {
      INSTANCE;

      @Override
      public RdfPrefixEntry create() {
        return RdfPrefixEntry.newInstance();
      }
    }
  }

  /**
   * Protobuf type {@code RdfDatatypeEntry}
   */
  public static final class RdfDatatypeEntry extends ProtoMessage<RdfDatatypeEntry> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 id = 1;</code>
     */
    private int id;

    /**
     * <code>optional string value = 2;</code>
     */
    private String value_ = null;

    private RdfDatatypeEntry() {
    }

    /**
     * @return a new empty instance of {@code RdfDatatypeEntry}
     */
    public static RdfDatatypeEntry newInstance() {
      return new RdfDatatypeEntry();
    }

    /**
     * <code>optional uint32 id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 id = 1;</code>
     * @return this
     */
    public RdfDatatypeEntry clearId() {
      bitField0_ &= ~0x00000001;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public RdfDatatypeEntry setId(final int value) {
      bitField0_ |= 0x00000001;
      id = value;
      return this;
    }

    private void initValue() {
      if (value_ == null) {
        value_ = "";
      }
    }

    /**
     * <code>optional string value = 2;</code>
     * @return whether the value_ field is set
     */
    public boolean hasValue() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional string value = 2;</code>
     * @return this
     */
    public RdfDatatypeEntry clearValue() {
      bitField0_ &= ~0x00000002;
      if (value_ != null) {
        value_ = "";
      }
      return this;
    }

    /**
     * <code>optional string value = 2;</code>
     * @return the value_
     */
    public String getValue() {
      initValue();
      return value_;
    }

    /**
     * <code>optional string value = 2;</code>
     * @param value the value_ to set
     * @return this
     */
    public RdfDatatypeEntry setValue(final String value) {
      initValue();
      bitField0_ |= 0x00000002;
      value_ = value;
      return this;
    }

    @Override
    public RdfDatatypeEntry copyFrom(final RdfDatatypeEntry other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        id = other.id;
        if (other.hasValue()) {
          initValue();
          value_ = other.value_;
        } else {
          clearValue();
        }
      }
      return this;
    }

    @Override
    public RdfDatatypeEntry mergeFrom(final RdfDatatypeEntry other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasValue()) {
        value_ = other.value_;
      }
      return this;
    }

    @Override
    public RdfDatatypeEntry clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      id = 0;
      if (value_ != null) {
        value_ = "";
      }
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof RdfDatatypeEntry)) {
        return false;
      }
      RdfDatatypeEntry other = (RdfDatatypeEntry) o;
      return bitField0_ == other.bitField0_
        && (!hasId() || id == other.id)
        && (!hasValue() || value_.equals(other.value_));
    }

    @Override
    public void writeTo(final CodedOutputStream output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 18);
        output.writeStringNoTag(value_);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + CodedOutputStream.computeStringSizeNoTag(value_);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public RdfDatatypeEntry mergeFrom(final CodedInputStream input) throws IOException {
      // Enabled Fall-Through Optimization (Quickbuf)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // value_
            initValue();
            value_ = input.readStringRequireUtf8();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public RdfDatatypeEntry clone() {
      return new RdfDatatypeEntry().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static RdfDatatypeEntry parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new RdfDatatypeEntry(), data).checkInitialized();
    }

    public static RdfDatatypeEntry parseFrom(final CodedInputStream input) throws IOException {
      return ProtoMessage.mergeFrom(new RdfDatatypeEntry(), input).checkInitialized();
    }

    /**
     * @return factory for creating RdfDatatypeEntry messages
     */
    public static MessageFactory<RdfDatatypeEntry> getFactory() {
      return RdfDatatypeEntryFactory.INSTANCE;
    }

    private enum RdfDatatypeEntryFactory implements MessageFactory<RdfDatatypeEntry> {
      INSTANCE;

      @Override
      public RdfDatatypeEntry create() {
        return RdfDatatypeEntry.newInstance();
      }
    }
  }

  /**
   * Protobuf type {@code RdfStreamOptions}
   */
  public static final class RdfStreamOptions extends ProtoMessage<RdfStreamOptions> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional string stream_name = 1;</code>
     */
    private String streamName = null;

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.PhysicalStreamType physical_type = 2;</code>
     */
    private int physicalType;

    /**
     * <code>optional bool generalized_statements = 3;</code>
     */
    private boolean generalizedStatements;

    /**
     * <code>optional bool rdf_star = 4;</code>
     */
    private boolean rdfStar;

    /**
     * <code>optional uint32 max_name_table_size = 9;</code>
     */
    private int maxNameTableSize;

    /**
     * <code>optional uint32 max_prefix_table_size = 10;</code>
     */
    private int maxPrefixTableSize;

    /**
     * <code>optional uint32 max_datatype_table_size = 11;</code>
     */
    private int maxDatatypeTableSize;

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.LogicalStreamType logical_type = 14;</code>
     */
    private int logicalType;

    /**
     * <code>optional uint32 version = 15;</code>
     */
    private int version;

    private RdfStreamOptions() {
    }

    /**
     * @return a new empty instance of {@code RdfStreamOptions}
     */
    public static RdfStreamOptions newInstance() {
      return new RdfStreamOptions();
    }

    private void initStreamName() {
      if (streamName == null) {
        streamName = "";
      }
    }

    /**
     * <code>optional string stream_name = 1;</code>
     * @return whether the streamName field is set
     */
    public boolean hasStreamName() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional string stream_name = 1;</code>
     * @return this
     */
    public RdfStreamOptions clearStreamName() {
      bitField0_ &= ~0x00000001;
      if (streamName != null) {
        streamName = "";
      }
      return this;
    }

    /**
     * <code>optional string stream_name = 1;</code>
     * @return the streamName
     */
    public String getStreamName() {
      initStreamName();
      return streamName;
    }

    /**
     * <code>optional string stream_name = 1;</code>
     * @param value the streamName to set
     * @return this
     */
    public RdfStreamOptions setStreamName(final String value) {
      initStreamName();
      bitField0_ |= 0x00000001;
      streamName = value;
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.PhysicalStreamType physical_type = 2;</code>
     * @return whether the physicalType field is set
     */
    public boolean hasPhysicalType() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.PhysicalStreamType physical_type = 2;</code>
     * @return this
     */
    public RdfStreamOptions clearPhysicalType() {
      bitField0_ &= ~0x00000002;
      physicalType = 0;
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.PhysicalStreamType physical_type = 2;</code>
     * @return the physicalType
     */
    public PhysicalStreamType getPhysicalType() {
      return PhysicalStreamType.forNumber(physicalType);
    }

    /**
     * Gets the value of the internal enum store. The result is
     * equivalent to {@link RdfStreamOptions#getPhysicalType()}.getNumber().
     *
     * @return numeric wire representation
     */
    public int getPhysicalTypeValue() {
      return physicalType;
    }

    /**
     * Sets the value of the internal enum store. This does not
     * do any validity checks, so be sure to use appropriate value
     * constants from {@link PhysicalStreamType}. Setting an invalid value
     * can cause {@link RdfStreamOptions#getPhysicalType()} to return null
     *
     * @param value the numeric wire value to set
     * @return this
     */
    public RdfStreamOptions setPhysicalTypeValue(final int value) {
      bitField0_ |= 0x00000002;
      physicalType = value;
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.PhysicalStreamType physical_type = 2;</code>
     * @param value the physicalType to set
     * @return this
     */
    public RdfStreamOptions setPhysicalType(final PhysicalStreamType value) {
      bitField0_ |= 0x00000002;
      physicalType = value.getNumber();
      return this;
    }

    /**
     * <code>optional bool generalized_statements = 3;</code>
     * @return whether the generalizedStatements field is set
     */
    public boolean hasGeneralizedStatements() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bool generalized_statements = 3;</code>
     * @return this
     */
    public RdfStreamOptions clearGeneralizedStatements() {
      bitField0_ &= ~0x00000004;
      generalizedStatements = false;
      return this;
    }

    /**
     * <code>optional bool generalized_statements = 3;</code>
     * @return the generalizedStatements
     */
    public boolean getGeneralizedStatements() {
      return generalizedStatements;
    }

    /**
     * <code>optional bool generalized_statements = 3;</code>
     * @param value the generalizedStatements to set
     * @return this
     */
    public RdfStreamOptions setGeneralizedStatements(final boolean value) {
      bitField0_ |= 0x00000004;
      generalizedStatements = value;
      return this;
    }

    /**
     * <code>optional bool rdf_star = 4;</code>
     * @return whether the rdfStar field is set
     */
    public boolean hasRdfStar() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bool rdf_star = 4;</code>
     * @return this
     */
    public RdfStreamOptions clearRdfStar() {
      bitField0_ &= ~0x00000008;
      rdfStar = false;
      return this;
    }

    /**
     * <code>optional bool rdf_star = 4;</code>
     * @return the rdfStar
     */
    public boolean getRdfStar() {
      return rdfStar;
    }

    /**
     * <code>optional bool rdf_star = 4;</code>
     * @param value the rdfStar to set
     * @return this
     */
    public RdfStreamOptions setRdfStar(final boolean value) {
      bitField0_ |= 0x00000008;
      rdfStar = value;
      return this;
    }

    /**
     * <code>optional uint32 max_name_table_size = 9;</code>
     * @return whether the maxNameTableSize field is set
     */
    public boolean hasMaxNameTableSize() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional uint32 max_name_table_size = 9;</code>
     * @return this
     */
    public RdfStreamOptions clearMaxNameTableSize() {
      bitField0_ &= ~0x00000010;
      maxNameTableSize = 0;
      return this;
    }

    /**
     * <code>optional uint32 max_name_table_size = 9;</code>
     * @return the maxNameTableSize
     */
    public int getMaxNameTableSize() {
      return maxNameTableSize;
    }

    /**
     * <code>optional uint32 max_name_table_size = 9;</code>
     * @param value the maxNameTableSize to set
     * @return this
     */
    public RdfStreamOptions setMaxNameTableSize(final int value) {
      bitField0_ |= 0x00000010;
      maxNameTableSize = value;
      return this;
    }

    /**
     * <code>optional uint32 max_prefix_table_size = 10;</code>
     * @return whether the maxPrefixTableSize field is set
     */
    public boolean hasMaxPrefixTableSize() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>optional uint32 max_prefix_table_size = 10;</code>
     * @return this
     */
    public RdfStreamOptions clearMaxPrefixTableSize() {
      bitField0_ &= ~0x00000020;
      maxPrefixTableSize = 0;
      return this;
    }

    /**
     * <code>optional uint32 max_prefix_table_size = 10;</code>
     * @return the maxPrefixTableSize
     */
    public int getMaxPrefixTableSize() {
      return maxPrefixTableSize;
    }

    /**
     * <code>optional uint32 max_prefix_table_size = 10;</code>
     * @param value the maxPrefixTableSize to set
     * @return this
     */
    public RdfStreamOptions setMaxPrefixTableSize(final int value) {
      bitField0_ |= 0x00000020;
      maxPrefixTableSize = value;
      return this;
    }

    /**
     * <code>optional uint32 max_datatype_table_size = 11;</code>
     * @return whether the maxDatatypeTableSize field is set
     */
    public boolean hasMaxDatatypeTableSize() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <code>optional uint32 max_datatype_table_size = 11;</code>
     * @return this
     */
    public RdfStreamOptions clearMaxDatatypeTableSize() {
      bitField0_ &= ~0x00000040;
      maxDatatypeTableSize = 0;
      return this;
    }

    /**
     * <code>optional uint32 max_datatype_table_size = 11;</code>
     * @return the maxDatatypeTableSize
     */
    public int getMaxDatatypeTableSize() {
      return maxDatatypeTableSize;
    }

    /**
     * <code>optional uint32 max_datatype_table_size = 11;</code>
     * @param value the maxDatatypeTableSize to set
     * @return this
     */
    public RdfStreamOptions setMaxDatatypeTableSize(final int value) {
      bitField0_ |= 0x00000040;
      maxDatatypeTableSize = value;
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.LogicalStreamType logical_type = 14;</code>
     * @return whether the logicalType field is set
     */
    public boolean hasLogicalType() {
      return (bitField0_ & 0x00000080) != 0;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.LogicalStreamType logical_type = 14;</code>
     * @return this
     */
    public RdfStreamOptions clearLogicalType() {
      bitField0_ &= ~0x00000080;
      logicalType = 0;
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.LogicalStreamType logical_type = 14;</code>
     * @return the logicalType
     */
    public LogicalStreamType getLogicalType() {
      return LogicalStreamType.forNumber(logicalType);
    }

    /**
     * Gets the value of the internal enum store. The result is
     * equivalent to {@link RdfStreamOptions#getLogicalType()}.getNumber().
     *
     * @return numeric wire representation
     */
    public int getLogicalTypeValue() {
      return logicalType;
    }

    /**
     * Sets the value of the internal enum store. This does not
     * do any validity checks, so be sure to use appropriate value
     * constants from {@link LogicalStreamType}. Setting an invalid value
     * can cause {@link RdfStreamOptions#getLogicalType()} to return null
     *
     * @param value the numeric wire value to set
     * @return this
     */
    public RdfStreamOptions setLogicalTypeValue(final int value) {
      bitField0_ |= 0x00000080;
      logicalType = value;
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.LogicalStreamType logical_type = 14;</code>
     * @param value the logicalType to set
     * @return this
     */
    public RdfStreamOptions setLogicalType(final LogicalStreamType value) {
      bitField0_ |= 0x00000080;
      logicalType = value.getNumber();
      return this;
    }

    /**
     * <code>optional uint32 version = 15;</code>
     * @return whether the version field is set
     */
    public boolean hasVersion() {
      return (bitField0_ & 0x00000100) != 0;
    }

    /**
     * <code>optional uint32 version = 15;</code>
     * @return this
     */
    public RdfStreamOptions clearVersion() {
      bitField0_ &= ~0x00000100;
      version = 0;
      return this;
    }

    /**
     * <code>optional uint32 version = 15;</code>
     * @return the version
     */
    public int getVersion() {
      return version;
    }

    /**
     * <code>optional uint32 version = 15;</code>
     * @param value the version to set
     * @return this
     */
    public RdfStreamOptions setVersion(final int value) {
      bitField0_ |= 0x00000100;
      version = value;
      return this;
    }

    @Override
    public RdfStreamOptions copyFrom(final RdfStreamOptions other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        if (other.hasStreamName()) {
          initStreamName();
          streamName = other.streamName;
        } else {
          clearStreamName();
        }
        physicalType = other.physicalType;
        generalizedStatements = other.generalizedStatements;
        rdfStar = other.rdfStar;
        maxNameTableSize = other.maxNameTableSize;
        maxPrefixTableSize = other.maxPrefixTableSize;
        maxDatatypeTableSize = other.maxDatatypeTableSize;
        logicalType = other.logicalType;
        version = other.version;
      }
      return this;
    }

    @Override
    public RdfStreamOptions mergeFrom(final RdfStreamOptions other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasStreamName()) {
        streamName = other.streamName;
      }
      if (other.hasPhysicalType()) {
        setPhysicalTypeValue(other.physicalType);
      }
      if (other.hasGeneralizedStatements()) {
        setGeneralizedStatements(other.generalizedStatements);
      }
      if (other.hasRdfStar()) {
        setRdfStar(other.rdfStar);
      }
      if (other.hasMaxNameTableSize()) {
        setMaxNameTableSize(other.maxNameTableSize);
      }
      if (other.hasMaxPrefixTableSize()) {
        setMaxPrefixTableSize(other.maxPrefixTableSize);
      }
      if (other.hasMaxDatatypeTableSize()) {
        setMaxDatatypeTableSize(other.maxDatatypeTableSize);
      }
      if (other.hasLogicalType()) {
        setLogicalTypeValue(other.logicalType);
      }
      if (other.hasVersion()) {
        setVersion(other.version);
      }
      return this;
    }

    @Override
    public RdfStreamOptions clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (streamName != null) {
        streamName = "";
      }
      physicalType = 0;
      generalizedStatements = false;
      rdfStar = false;
      maxNameTableSize = 0;
      maxPrefixTableSize = 0;
      maxDatatypeTableSize = 0;
      logicalType = 0;
      version = 0;
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof RdfStreamOptions)) {
        return false;
      }
      RdfStreamOptions other = (RdfStreamOptions) o;
      return bitField0_ == other.bitField0_
        && (!hasStreamName() || streamName.equals(other.streamName))
        && (!hasPhysicalType() || physicalType == other.physicalType)
        && (!hasGeneralizedStatements() || generalizedStatements == other.generalizedStatements)
        && (!hasRdfStar() || rdfStar == other.rdfStar)
        && (!hasMaxNameTableSize() || maxNameTableSize == other.maxNameTableSize)
        && (!hasMaxPrefixTableSize() || maxPrefixTableSize == other.maxPrefixTableSize)
        && (!hasMaxDatatypeTableSize() || maxDatatypeTableSize == other.maxDatatypeTableSize)
        && (!hasLogicalType() || logicalType == other.logicalType)
        && (!hasVersion() || version == other.version);
    }

    @Override
    public void writeTo(final CodedOutputStream output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 10);
        output.writeStringNoTag(streamName);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeEnumNoTag(physicalType);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 24);
        output.writeBoolNoTag(generalizedStatements);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 32);
        output.writeBoolNoTag(rdfStar);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawByte((byte) 72);
        output.writeUInt32NoTag(maxNameTableSize);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRawByte((byte) 80);
        output.writeUInt32NoTag(maxPrefixTableSize);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeRawByte((byte) 88);
        output.writeUInt32NoTag(maxDatatypeTableSize);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeRawByte((byte) 112);
        output.writeEnumNoTag(logicalType);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        output.writeRawByte((byte) 120);
        output.writeUInt32NoTag(version);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + CodedOutputStream.computeStringSizeNoTag(streamName);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + CodedOutputStream.computeEnumSizeNoTag(physicalType);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(maxNameTableSize);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(maxPrefixTableSize);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(maxDatatypeTableSize);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        size += 1 + CodedOutputStream.computeEnumSizeNoTag(logicalType);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(version);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public RdfStreamOptions mergeFrom(final CodedInputStream input) throws IOException {
      // Enabled Fall-Through Optimization (Quickbuf)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 10: {
            // streamName
            initStreamName();
            streamName = input.readStringRequireUtf8();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // physicalType
            final int value = input.readInt32();
            if (PhysicalStreamType.forNumber(value) != null) {
              physicalType = value;
              bitField0_ |= 0x00000002;
            }
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // generalizedStatements
            generalizedStatements = input.readBool();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            // rdfStar
            rdfStar = input.readBool();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 72) {
              break;
            }
          }
          case 72: {
            // maxNameTableSize
            maxNameTableSize = input.readUInt32();
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 80) {
              break;
            }
          }
          case 80: {
            // maxPrefixTableSize
            maxPrefixTableSize = input.readUInt32();
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 88) {
              break;
            }
          }
          case 88: {
            // maxDatatypeTableSize
            maxDatatypeTableSize = input.readUInt32();
            bitField0_ |= 0x00000040;
            tag = input.readTag();
            if (tag != 112) {
              break;
            }
          }
          case 112: {
            // logicalType
            final int value = input.readInt32();
            if (LogicalStreamType.forNumber(value) != null) {
              logicalType = value;
              bitField0_ |= 0x00000080;
            }
            tag = input.readTag();
            if (tag != 120) {
              break;
            }
          }
          case 120: {
            // version
            version = input.readUInt32();
            bitField0_ |= 0x00000100;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public RdfStreamOptions clone() {
      return new RdfStreamOptions().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static RdfStreamOptions parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new RdfStreamOptions(), data).checkInitialized();
    }

    public static RdfStreamOptions parseFrom(final CodedInputStream input) throws IOException {
      return ProtoMessage.mergeFrom(new RdfStreamOptions(), input).checkInitialized();
    }

    /**
     * @return factory for creating RdfStreamOptions messages
     */
    public static MessageFactory<RdfStreamOptions> getFactory() {
      return RdfStreamOptionsFactory.INSTANCE;
    }

    private enum RdfStreamOptionsFactory implements MessageFactory<RdfStreamOptions> {
      INSTANCE;

      @Override
      public RdfStreamOptions create() {
        return RdfStreamOptions.newInstance();
      }
    }
  }

  /**
   * Protobuf type {@code RdfStreamRow}
   */
  public static final class RdfStreamRow extends ProtoMessage<RdfStreamRow> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfStreamOptions options = 1;</code>
     */
    private RdfStreamOptions options = null;

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple triple = 2;</code>
     */
    private RdfTriple triple = null;

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfQuad quad = 3;</code>
     */
    private RdfQuad quad = null;

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfGraphStart graph_start = 4;</code>
     */
    private RdfGraphStart graphStart = null;

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfGraphEnd graph_end = 5;</code>
     */
    private RdfGraphEnd graphEnd = null;

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfNamespaceDeclaration namespace = 6;</code>
     */
    private RdfNamespaceDeclaration namespace = null;

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfNameEntry name = 9;</code>
     */
    private RdfNameEntry name = null;

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfPrefixEntry prefix = 10;</code>
     */
    private RdfPrefixEntry prefix = null;

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfDatatypeEntry datatype = 11;</code>
     */
    private RdfDatatypeEntry datatype = null;

    private RdfStreamRow() {
    }

    /**
     * @return a new empty instance of {@code RdfStreamRow}
     */
    public static RdfStreamRow newInstance() {
      return new RdfStreamRow();
    }

    public boolean hasRow() {
      return (((bitField0_ & 0x000001ff)) != 0);
    }

    public RdfStreamRow clearRow() {
      if (hasRow()) {
        clearOptions();
        clearTriple();
        clearQuad();
        clearGraphStart();
        clearGraphEnd();
        clearNamespace();
        clearName();
        clearPrefix();
        clearDatatype();
      }
      return this;
    }

    private void clearRowOtherOptions() {
      if ((((bitField0_ & 0x000001fe)) != 0)) {
        clearTriple();
        clearQuad();
        clearGraphStart();
        clearGraphEnd();
        clearNamespace();
        clearName();
        clearPrefix();
        clearDatatype();
      }
    }

    private void clearRowOtherTriple() {
      if ((((bitField0_ & 0x000001fd)) != 0)) {
        clearOptions();
        clearQuad();
        clearGraphStart();
        clearGraphEnd();
        clearNamespace();
        clearName();
        clearPrefix();
        clearDatatype();
      }
    }

    private void clearRowOtherQuad() {
      if ((((bitField0_ & 0x000001fb)) != 0)) {
        clearOptions();
        clearTriple();
        clearGraphStart();
        clearGraphEnd();
        clearNamespace();
        clearName();
        clearPrefix();
        clearDatatype();
      }
    }

    private void clearRowOtherGraphStart() {
      if ((((bitField0_ & 0x000001f7)) != 0)) {
        clearOptions();
        clearTriple();
        clearQuad();
        clearGraphEnd();
        clearNamespace();
        clearName();
        clearPrefix();
        clearDatatype();
      }
    }

    private void clearRowOtherGraphEnd() {
      if ((((bitField0_ & 0x000001ef)) != 0)) {
        clearOptions();
        clearTriple();
        clearQuad();
        clearGraphStart();
        clearNamespace();
        clearName();
        clearPrefix();
        clearDatatype();
      }
    }

    private void clearRowOtherNamespace() {
      if ((((bitField0_ & 0x000001df)) != 0)) {
        clearOptions();
        clearTriple();
        clearQuad();
        clearGraphStart();
        clearGraphEnd();
        clearName();
        clearPrefix();
        clearDatatype();
      }
    }

    private void clearRowOtherName() {
      if ((((bitField0_ & 0x000001bf)) != 0)) {
        clearOptions();
        clearTriple();
        clearQuad();
        clearGraphStart();
        clearGraphEnd();
        clearNamespace();
        clearPrefix();
        clearDatatype();
      }
    }

    private void clearRowOtherPrefix() {
      if ((((bitField0_ & 0x0000017f)) != 0)) {
        clearOptions();
        clearTriple();
        clearQuad();
        clearGraphStart();
        clearGraphEnd();
        clearNamespace();
        clearName();
        clearDatatype();
      }
    }

    private void clearRowOtherDatatype() {
      if ((((bitField0_ & 0x000000ff)) != 0)) {
        clearOptions();
        clearTriple();
        clearQuad();
        clearGraphStart();
        clearGraphEnd();
        clearNamespace();
        clearName();
        clearPrefix();
      }
    }

    private void initOptions() {
      if (options == null) {
        options = RdfStreamOptions.newInstance();
      }
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfStreamOptions options = 1;</code>
     * @return whether the options field is set
     */
    public boolean hasOptions() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfStreamOptions options = 1;</code>
     * @return this
     */
    public RdfStreamRow clearOptions() {
      bitField0_ &= ~0x00000001;
      if (options != null) {
        options.clear();
      }
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfStreamOptions options = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableOptions()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RdfStreamOptions getOptions() {
      initOptions();
      return options;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfStreamOptions options = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RdfStreamOptions getMutableOptions() {
      clearRowOtherOptions();
      initOptions();
      bitField0_ |= 0x00000001;
      return options;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfStreamOptions options = 1;</code>
     * @param value the options to set
     * @return this
     */
    public RdfStreamRow setOptions(final RdfStreamOptions value) {
      clearRowOtherOptions();
      initOptions();
      bitField0_ |= 0x00000001;
      options.copyFrom(value);
      return this;
    }

    private void initTriple() {
      if (triple == null) {
        triple = RdfTriple.newInstance();
      }
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple triple = 2;</code>
     * @return whether the triple field is set
     */
    public boolean hasTriple() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple triple = 2;</code>
     * @return this
     */
    public RdfStreamRow clearTriple() {
      bitField0_ &= ~0x00000002;
      if (triple != null) {
        triple.clear();
      }
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple triple = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableTriple()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RdfTriple getTriple() {
      initTriple();
      return triple;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple triple = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RdfTriple getMutableTriple() {
      clearRowOtherTriple();
      initTriple();
      bitField0_ |= 0x00000002;
      return triple;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple triple = 2;</code>
     * @param value the triple to set
     * @return this
     */
    public RdfStreamRow setTriple(final RdfTriple value) {
      clearRowOtherTriple();
      initTriple();
      bitField0_ |= 0x00000002;
      triple.copyFrom(value);
      return this;
    }

    private void initQuad() {
      if (quad == null) {
        quad = RdfQuad.newInstance();
      }
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfQuad quad = 3;</code>
     * @return whether the quad field is set
     */
    public boolean hasQuad() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfQuad quad = 3;</code>
     * @return this
     */
    public RdfStreamRow clearQuad() {
      bitField0_ &= ~0x00000004;
      if (quad != null) {
        quad.clear();
      }
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfQuad quad = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableQuad()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RdfQuad getQuad() {
      initQuad();
      return quad;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfQuad quad = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RdfQuad getMutableQuad() {
      clearRowOtherQuad();
      initQuad();
      bitField0_ |= 0x00000004;
      return quad;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfQuad quad = 3;</code>
     * @param value the quad to set
     * @return this
     */
    public RdfStreamRow setQuad(final RdfQuad value) {
      clearRowOtherQuad();
      initQuad();
      bitField0_ |= 0x00000004;
      quad.copyFrom(value);
      return this;
    }

    private void initGraphStart() {
      if (graphStart == null) {
        graphStart = RdfGraphStart.newInstance();
      }
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfGraphStart graph_start = 4;</code>
     * @return whether the graphStart field is set
     */
    public boolean hasGraphStart() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfGraphStart graph_start = 4;</code>
     * @return this
     */
    public RdfStreamRow clearGraphStart() {
      bitField0_ &= ~0x00000008;
      if (graphStart != null) {
        graphStart.clear();
      }
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfGraphStart graph_start = 4;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableGraphStart()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RdfGraphStart getGraphStart() {
      initGraphStart();
      return graphStart;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfGraphStart graph_start = 4;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RdfGraphStart getMutableGraphStart() {
      clearRowOtherGraphStart();
      initGraphStart();
      bitField0_ |= 0x00000008;
      return graphStart;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfGraphStart graph_start = 4;</code>
     * @param value the graphStart to set
     * @return this
     */
    public RdfStreamRow setGraphStart(final RdfGraphStart value) {
      clearRowOtherGraphStart();
      initGraphStart();
      bitField0_ |= 0x00000008;
      graphStart.copyFrom(value);
      return this;
    }

    private void initGraphEnd() {
      if (graphEnd == null) {
        graphEnd = RdfGraphEnd.newInstance();
      }
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfGraphEnd graph_end = 5;</code>
     * @return whether the graphEnd field is set
     */
    public boolean hasGraphEnd() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfGraphEnd graph_end = 5;</code>
     * @return this
     */
    public RdfStreamRow clearGraphEnd() {
      bitField0_ &= ~0x00000010;
      if (graphEnd != null) {
        graphEnd.clear();
      }
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfGraphEnd graph_end = 5;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableGraphEnd()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RdfGraphEnd getGraphEnd() {
      initGraphEnd();
      return graphEnd;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfGraphEnd graph_end = 5;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RdfGraphEnd getMutableGraphEnd() {
      clearRowOtherGraphEnd();
      initGraphEnd();
      bitField0_ |= 0x00000010;
      return graphEnd;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfGraphEnd graph_end = 5;</code>
     * @param value the graphEnd to set
     * @return this
     */
    public RdfStreamRow setGraphEnd(final RdfGraphEnd value) {
      clearRowOtherGraphEnd();
      initGraphEnd();
      bitField0_ |= 0x00000010;
      graphEnd.copyFrom(value);
      return this;
    }

    private void initNamespace() {
      if (namespace == null) {
        namespace = RdfNamespaceDeclaration.newInstance();
      }
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfNamespaceDeclaration namespace = 6;</code>
     * @return whether the namespace field is set
     */
    public boolean hasNamespace() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfNamespaceDeclaration namespace = 6;</code>
     * @return this
     */
    public RdfStreamRow clearNamespace() {
      bitField0_ &= ~0x00000020;
      if (namespace != null) {
        namespace.clear();
      }
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfNamespaceDeclaration namespace = 6;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNamespace()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RdfNamespaceDeclaration getNamespace() {
      initNamespace();
      return namespace;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfNamespaceDeclaration namespace = 6;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RdfNamespaceDeclaration getMutableNamespace() {
      clearRowOtherNamespace();
      initNamespace();
      bitField0_ |= 0x00000020;
      return namespace;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfNamespaceDeclaration namespace = 6;</code>
     * @param value the namespace to set
     * @return this
     */
    public RdfStreamRow setNamespace(final RdfNamespaceDeclaration value) {
      clearRowOtherNamespace();
      initNamespace();
      bitField0_ |= 0x00000020;
      namespace.copyFrom(value);
      return this;
    }

    private void initName() {
      if (name == null) {
        name = RdfNameEntry.newInstance();
      }
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfNameEntry name = 9;</code>
     * @return whether the name field is set
     */
    public boolean hasName() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfNameEntry name = 9;</code>
     * @return this
     */
    public RdfStreamRow clearName() {
      bitField0_ &= ~0x00000040;
      if (name != null) {
        name.clear();
      }
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfNameEntry name = 9;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableName()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RdfNameEntry getName() {
      initName();
      return name;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfNameEntry name = 9;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RdfNameEntry getMutableName() {
      clearRowOtherName();
      initName();
      bitField0_ |= 0x00000040;
      return name;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfNameEntry name = 9;</code>
     * @param value the name to set
     * @return this
     */
    public RdfStreamRow setName(final RdfNameEntry value) {
      clearRowOtherName();
      initName();
      bitField0_ |= 0x00000040;
      name.copyFrom(value);
      return this;
    }

    private void initPrefix() {
      if (prefix == null) {
        prefix = RdfPrefixEntry.newInstance();
      }
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfPrefixEntry prefix = 10;</code>
     * @return whether the prefix field is set
     */
    public boolean hasPrefix() {
      return (bitField0_ & 0x00000080) != 0;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfPrefixEntry prefix = 10;</code>
     * @return this
     */
    public RdfStreamRow clearPrefix() {
      bitField0_ &= ~0x00000080;
      if (prefix != null) {
        prefix.clear();
      }
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfPrefixEntry prefix = 10;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutablePrefix()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RdfPrefixEntry getPrefix() {
      initPrefix();
      return prefix;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfPrefixEntry prefix = 10;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RdfPrefixEntry getMutablePrefix() {
      clearRowOtherPrefix();
      initPrefix();
      bitField0_ |= 0x00000080;
      return prefix;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfPrefixEntry prefix = 10;</code>
     * @param value the prefix to set
     * @return this
     */
    public RdfStreamRow setPrefix(final RdfPrefixEntry value) {
      clearRowOtherPrefix();
      initPrefix();
      bitField0_ |= 0x00000080;
      prefix.copyFrom(value);
      return this;
    }

    private void initDatatype() {
      if (datatype == null) {
        datatype = RdfDatatypeEntry.newInstance();
      }
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfDatatypeEntry datatype = 11;</code>
     * @return whether the datatype field is set
     */
    public boolean hasDatatype() {
      return (bitField0_ & 0x00000100) != 0;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfDatatypeEntry datatype = 11;</code>
     * @return this
     */
    public RdfStreamRow clearDatatype() {
      bitField0_ &= ~0x00000100;
      if (datatype != null) {
        datatype.clear();
      }
      return this;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfDatatypeEntry datatype = 11;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableDatatype()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RdfDatatypeEntry getDatatype() {
      initDatatype();
      return datatype;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfDatatypeEntry datatype = 11;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RdfDatatypeEntry getMutableDatatype() {
      clearRowOtherDatatype();
      initDatatype();
      bitField0_ |= 0x00000100;
      return datatype;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfDatatypeEntry datatype = 11;</code>
     * @param value the datatype to set
     * @return this
     */
    public RdfStreamRow setDatatype(final RdfDatatypeEntry value) {
      clearRowOtherDatatype();
      initDatatype();
      bitField0_ |= 0x00000100;
      datatype.copyFrom(value);
      return this;
    }

    @Override
    public RdfStreamRow copyFrom(final RdfStreamRow other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        if (other.hasOptions()) {
          initOptions();
          options.copyFrom(other.options);
        } else {
          clearOptions();
        }
        if (other.hasTriple()) {
          initTriple();
          triple.copyFrom(other.triple);
        } else {
          clearTriple();
        }
        if (other.hasQuad()) {
          initQuad();
          quad.copyFrom(other.quad);
        } else {
          clearQuad();
        }
        if (other.hasGraphStart()) {
          initGraphStart();
          graphStart.copyFrom(other.graphStart);
        } else {
          clearGraphStart();
        }
        if (other.hasGraphEnd()) {
          initGraphEnd();
          graphEnd.copyFrom(other.graphEnd);
        } else {
          clearGraphEnd();
        }
        if (other.hasNamespace()) {
          initNamespace();
          namespace.copyFrom(other.namespace);
        } else {
          clearNamespace();
        }
        if (other.hasName()) {
          initName();
          name.copyFrom(other.name);
        } else {
          clearName();
        }
        if (other.hasPrefix()) {
          initPrefix();
          prefix.copyFrom(other.prefix);
        } else {
          clearPrefix();
        }
        if (other.hasDatatype()) {
          initDatatype();
          datatype.copyFrom(other.datatype);
        } else {
          clearDatatype();
        }
      }
      return this;
    }

    @Override
    public RdfStreamRow mergeFrom(final RdfStreamRow other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasOptions()) {
        getMutableOptions().mergeFrom(other.options);
      }
      if (other.hasTriple()) {
        getMutableTriple().mergeFrom(other.triple);
      }
      if (other.hasQuad()) {
        getMutableQuad().mergeFrom(other.quad);
      }
      if (other.hasGraphStart()) {
        getMutableGraphStart().mergeFrom(other.graphStart);
      }
      if (other.hasGraphEnd()) {
        getMutableGraphEnd().mergeFrom(other.graphEnd);
      }
      if (other.hasNamespace()) {
        getMutableNamespace().mergeFrom(other.namespace);
      }
      if (other.hasName()) {
        getMutableName().mergeFrom(other.name);
      }
      if (other.hasPrefix()) {
        getMutablePrefix().mergeFrom(other.prefix);
      }
      if (other.hasDatatype()) {
        getMutableDatatype().mergeFrom(other.datatype);
      }
      return this;
    }

    @Override
    public RdfStreamRow clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (options != null) {
        options.clear();
      }
      if (triple != null) {
        triple.clear();
      }
      if (quad != null) {
        quad.clear();
      }
      if (graphStart != null) {
        graphStart.clear();
      }
      if (graphEnd != null) {
        graphEnd.clear();
      }
      if (namespace != null) {
        namespace.clear();
      }
      if (name != null) {
        name.clear();
      }
      if (prefix != null) {
        prefix.clear();
      }
      if (datatype != null) {
        datatype.clear();
      }
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof RdfStreamRow)) {
        return false;
      }
      RdfStreamRow other = (RdfStreamRow) o;
      return bitField0_ == other.bitField0_
        && (!hasOptions() || options.equals(other.options))
        && (!hasTriple() || triple.equals(other.triple))
        && (!hasQuad() || quad.equals(other.quad))
        && (!hasGraphStart() || graphStart.equals(other.graphStart))
        && (!hasGraphEnd() || graphEnd.equals(other.graphEnd))
        && (!hasNamespace() || namespace.equals(other.namespace))
        && (!hasName() || name.equals(other.name))
        && (!hasPrefix() || prefix.equals(other.prefix))
        && (!hasDatatype() || datatype.equals(other.datatype));
    }

    @Override
    public void writeTo(final CodedOutputStream output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 10);
        output.writeUInt32NoTag(options.getCachedSize());
        options.writeTo(output);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 18);
        output.writeUInt32NoTag(triple.getCachedSize());
        triple.writeTo(output);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 26);
        output.writeUInt32NoTag(quad.getCachedSize());
        quad.writeTo(output);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 34);
        output.writeUInt32NoTag(graphStart.getCachedSize());
        graphStart.writeTo(output);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawByte((byte) 42);
        output.writeUInt32NoTag(graphEnd.getCachedSize());
        graphEnd.writeTo(output);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRawByte((byte) 50);
        output.writeUInt32NoTag(namespace.getCachedSize());
        namespace.writeTo(output);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeRawByte((byte) 74);
        output.writeUInt32NoTag(name.getCachedSize());
        name.writeTo(output);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeRawByte((byte) 82);
        output.writeUInt32NoTag(prefix.getCachedSize());
        prefix.writeTo(output);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        output.writeRawByte((byte) 90);
        output.writeUInt32NoTag(datatype.getCachedSize());
        datatype.writeTo(output);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        final int dataSize = options.getSerializedSize();
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
      }
      if ((bitField0_ & 0x00000002) != 0) {
        final int dataSize = triple.getSerializedSize();
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
      }
      if ((bitField0_ & 0x00000004) != 0) {
        final int dataSize = quad.getSerializedSize();
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
      }
      if ((bitField0_ & 0x00000008) != 0) {
        final int dataSize = graphStart.getSerializedSize();
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
      }
      if ((bitField0_ & 0x00000010) != 0) {
        final int dataSize = graphEnd.getSerializedSize();
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
      }
      if ((bitField0_ & 0x00000020) != 0) {
        final int dataSize = namespace.getSerializedSize();
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
      }
      if ((bitField0_ & 0x00000040) != 0) {
        final int dataSize = name.getSerializedSize();
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
      }
      if ((bitField0_ & 0x00000080) != 0) {
        final int dataSize = prefix.getSerializedSize();
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
      }
      if ((bitField0_ & 0x00000100) != 0) {
        final int dataSize = datatype.getSerializedSize();
        size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public RdfStreamRow mergeFrom(final CodedInputStream input) throws IOException {
      // Enabled Fall-Through Optimization (Quickbuf)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 10: {
            // options
            clearRowOtherOptions();
            initOptions();
            ProtoMessage.mergeDelimitedFrom(options, input);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // triple
            clearRowOtherTriple();
            initTriple();
            ProtoMessage.mergeDelimitedFrom(triple, input);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // quad
            clearRowOtherQuad();
            initQuad();
            ProtoMessage.mergeDelimitedFrom(quad, input);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 34) {
              break;
            }
          }
          case 34: {
            // graphStart
            clearRowOtherGraphStart();
            initGraphStart();
            ProtoMessage.mergeDelimitedFrom(graphStart, input);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 42) {
              break;
            }
          }
          case 42: {
            // graphEnd
            clearRowOtherGraphEnd();
            initGraphEnd();
            ProtoMessage.mergeDelimitedFrom(graphEnd, input);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 50) {
              break;
            }
          }
          case 50: {
            // namespace
            clearRowOtherNamespace();
            initNamespace();
            ProtoMessage.mergeDelimitedFrom(namespace, input);
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 74) {
              break;
            }
          }
          case 74: {
            // name
            clearRowOtherName();
            initName();
            ProtoMessage.mergeDelimitedFrom(name, input);
            bitField0_ |= 0x00000040;
            tag = input.readTag();
            if (tag != 82) {
              break;
            }
          }
          case 82: {
            // prefix
            clearRowOtherPrefix();
            initPrefix();
            ProtoMessage.mergeDelimitedFrom(prefix, input);
            bitField0_ |= 0x00000080;
            tag = input.readTag();
            if (tag != 90) {
              break;
            }
          }
          case 90: {
            // datatype
            clearRowOtherDatatype();
            initDatatype();
            ProtoMessage.mergeDelimitedFrom(datatype, input);
            bitField0_ |= 0x00000100;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public RdfStreamRow clone() {
      return new RdfStreamRow().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static RdfStreamRow parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new RdfStreamRow(), data).checkInitialized();
    }

    public static RdfStreamRow parseFrom(final CodedInputStream input) throws IOException {
      return ProtoMessage.mergeFrom(new RdfStreamRow(), input).checkInitialized();
    }

    /**
     * @return factory for creating RdfStreamRow messages
     */
    public static MessageFactory<RdfStreamRow> getFactory() {
      return RdfStreamRowFactory.INSTANCE;
    }

    private enum RdfStreamRowFactory implements MessageFactory<RdfStreamRow> {
      INSTANCE;

      @Override
      public RdfStreamRow create() {
        return RdfStreamRow.newInstance();
      }
    }
  }

  /**
   * Protobuf type {@code RdfStreamFrame}
   */
  public static final class RdfStreamFrame extends ProtoMessage<RdfStreamFrame> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>repeated .eu.ostrzyciel.jelly.core.proto.v1.RdfStreamRow rows = 1;</code>
     */
    private List<RdfStreamRow> rows = null;

    /**
     * <code>repeated .eu.ostrzyciel.jelly.core.proto.v1.RdfStreamFrame.MetadataEntry metadata = 15;</code>
     */
    private List<MetadataEntry> metadata = null;

    private RdfStreamFrame() {
    }

    /**
     * @return a new empty instance of {@code RdfStreamFrame}
     */
    public static RdfStreamFrame newInstance() {
      return new RdfStreamFrame();
    }

    private void initRows() {
      if (rows == null) {
        rows = Collections.emptyList();
      }
    }

    /**
     * <code>repeated .eu.ostrzyciel.jelly.core.proto.v1.RdfStreamRow rows = 1;</code>
     * @return whether the rows field is set
     */
    public boolean hasRows() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>repeated .eu.ostrzyciel.jelly.core.proto.v1.RdfStreamRow rows = 1;</code>
     * @return this
     */
    public RdfStreamFrame clearRows() {
      bitField0_ &= ~0x00000001;
      if (rows != null) {
        rows.clear();
      }
      return this;
    }

    /**
     * <code>repeated .eu.ostrzyciel.jelly.core.proto.v1.RdfStreamRow rows = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableRows()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public List<RdfStreamRow> getRows() {
      initRows();
      return rows;
    }

    /**
     * <code>repeated .eu.ostrzyciel.jelly.core.proto.v1.RdfStreamRow rows = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public List<RdfStreamRow> getMutableRows() {
      initRows();
      bitField0_ |= 0x00000001;
      return rows;
    }

    /**
     * <code>repeated .eu.ostrzyciel.jelly.core.proto.v1.RdfStreamRow rows = 1;</code>
     * @param value the rows to add
     * @return this
     */
    public RdfStreamFrame addRows(final RdfStreamRow value) {
      initRows();
      bitField0_ |= 0x00000001;
      rows.add(value);
      return this;
    }

    private void initMetadata() {
      if (metadata == null) {
        metadata = Collections.emptyList();
      }
    }

    /**
     * <code>repeated .eu.ostrzyciel.jelly.core.proto.v1.RdfStreamFrame.MetadataEntry metadata = 15;</code>
     * @return whether the metadata field is set
     */
    public boolean hasMetadata() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated .eu.ostrzyciel.jelly.core.proto.v1.RdfStreamFrame.MetadataEntry metadata = 15;</code>
     * @return this
     */
    public RdfStreamFrame clearMetadata() {
      bitField0_ &= ~0x00000002;
      if (metadata != null) {
        metadata.clear();
      }
      return this;
    }

    /**
     * <code>repeated .eu.ostrzyciel.jelly.core.proto.v1.RdfStreamFrame.MetadataEntry metadata = 15;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableMetadata()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public List<MetadataEntry> getMetadata() {
      initMetadata();
      return metadata;
    }

    /**
     * <code>repeated .eu.ostrzyciel.jelly.core.proto.v1.RdfStreamFrame.MetadataEntry metadata = 15;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public List<MetadataEntry> getMutableMetadata() {
      initMetadata();
      bitField0_ |= 0x00000002;
      return metadata;
    }

    /**
     * <code>repeated .eu.ostrzyciel.jelly.core.proto.v1.RdfStreamFrame.MetadataEntry metadata = 15;</code>
     * @param value the metadata to add
     * @return this
     */
    public RdfStreamFrame addMetadata(final MetadataEntry value) {
      initMetadata();
      bitField0_ |= 0x00000002;
      metadata.add(value);
      return this;
    }

    @Override
    public RdfStreamFrame copyFrom(final RdfStreamFrame other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        if (other.hasRows()) {
          initRows();
          rows.addAll(other.rows);
        } else {
          clearRows();
        }
        if (other.hasMetadata()) {
          initMetadata();
          metadata.addAll(other.metadata);
        } else {
          clearMetadata();
        }
      }
      return this;
    }

    @Override
    public RdfStreamFrame mergeFrom(final RdfStreamFrame other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasRows()) {
        getMutableRows().addAll(other.rows);
      }
      if (other.hasMetadata()) {
        getMutableMetadata().addAll(other.metadata);
      }
      return this;
    }

    @Override
    public RdfStreamFrame clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (rows != null) {
        rows.clear();
      }
      if (metadata != null) {
        metadata.clear();
      }
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof RdfStreamFrame)) {
        return false;
      }
      RdfStreamFrame other = (RdfStreamFrame) o;
      return bitField0_ == other.bitField0_
        && (!hasRows() || rows.equals(other.rows))
        && (!hasMetadata() || metadata.equals(other.metadata));
    }

    @Override
    public void writeTo(final CodedOutputStream output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        for (final var _field : rows) {
          output.writeRawByte((byte) 10);
          output.writeUInt32NoTag(_field.getCachedSize());
          _field.writeTo(output);
        }
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (final var _field : metadata) {
          output.writeRawByte((byte) 122);
          output.writeUInt32NoTag(_field.getCachedSize());
          _field.writeTo(output);
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += rows.size() + RepeatedMessage.computeRepeatedMessageSizeNoTag(rows);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += metadata.size() + RepeatedMessage.computeRepeatedMessageSizeNoTag(metadata);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public RdfStreamFrame mergeFrom(final CodedInputStream input) throws IOException {
      // Enabled Fall-Through Optimization (Quickbuf)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 10: {
            // rows
            initRows();
            tag = input.readRepeatedMessage(rows, tag);
            bitField0_ |= 0x00000001;
            if (tag != 122) {
              break;
            }
          }
          case 122: {
            // metadata
            initMetadata();
            tag = input.readRepeatedMessage(metadata, tag);
            bitField0_ |= 0x00000002;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public RdfStreamFrame clone() {
      return new RdfStreamFrame().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static RdfStreamFrame parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new RdfStreamFrame(), data).checkInitialized();
    }

    public static RdfStreamFrame parseFrom(final CodedInputStream input) throws IOException {
      return ProtoMessage.mergeFrom(new RdfStreamFrame(), input).checkInitialized();
    }

    /**
     * @return factory for creating RdfStreamFrame messages
     */
    public static MessageFactory<RdfStreamFrame> getFactory() {
      return RdfStreamFrameFactory.INSTANCE;
    }

    /**
     * Protobuf type {@code MetadataEntry}
     */
    public static final class MetadataEntry extends ProtoMessage<MetadataEntry> implements Cloneable {
      private static final long serialVersionUID = 0L;

      /**
       * <code>optional string key = 1;</code>
       */
      private String key = null;

      /**
       * <code>optional bytes value = 2;</code>
       */
      private ByteString value_ = null;

      private MetadataEntry() {
      }

      /**
       * @return a new empty instance of {@code MetadataEntry}
       */
      public static MetadataEntry newInstance() {
        return new MetadataEntry();
      }

      private void initKey() {
        if (key == null) {
          key = "";
        }
      }

      /**
       * <code>optional string key = 1;</code>
       * @return whether the key field is set
       */
      public boolean hasKey() {
        return (bitField0_ & 0x00000001) != 0;
      }

      /**
       * <code>optional string key = 1;</code>
       * @return this
       */
      public MetadataEntry clearKey() {
        bitField0_ &= ~0x00000001;
        if (key != null) {
          key = "";
        }
        return this;
      }

      /**
       * <code>optional string key = 1;</code>
       * @return the key
       */
      public String getKey() {
        initKey();
        return key;
      }

      /**
       * <code>optional string key = 1;</code>
       * @param value the key to set
       * @return this
       */
      public MetadataEntry setKey(final String value) {
        initKey();
        bitField0_ |= 0x00000001;
        key = value;
        return this;
      }

      private void initValue() {
        if (value_ == null) {
          value_ = ByteString.EMPTY;
        }
      }

      /**
       * <code>optional bytes value = 2;</code>
       * @return whether the value_ field is set
       */
      public boolean hasValue() {
        return (bitField0_ & 0x00000002) != 0;
      }

      /**
       * <code>optional bytes value = 2;</code>
       * @return this
       */
      public MetadataEntry clearValue() {
        bitField0_ &= ~0x00000002;
        if (value_ != null) {
          value_ = ByteString.EMPTY;
        }
        return this;
      }

      /**
       * <code>optional bytes value = 2;</code>
       *
       * This method returns the internal storage object without modifying any has state.
       * The returned object should not be modified and be treated as read-only.
       *
       * Use {@link #getMutableValue()} if you want to modify it.
       *
       * @return internal storage object for reading
       */
      public ByteString getValue() {
        initValue();
        return value_;
      }

      /**
       * <code>optional bytes value = 2;</code>
       *
       * This method returns the internal storage object and sets the corresponding
       * has state. The returned object will become part of this message and its
       * contents may be modified as long as the has state is not cleared.
       *
       * @return internal storage object for modifications
       */
      public ByteString getMutableValue() {
        initValue();
        bitField0_ |= 0x00000002;
        return value_;
      }

      /**
       * <code>optional bytes value = 2;</code>
       * @param value the value_ to add
       * @return this
       */
      public MetadataEntry addValue(final byte value) {
        initValue();
        bitField0_ |= 0x00000002;
        value_.add(value);
        return this;
      }

      /**
       * <code>optional bytes value = 2;</code>
       * @param values the value_ to set
       * @return this
       */
      public MetadataEntry setValue(final byte... values) {
        initValue();
        bitField0_ |= 0x00000002;
        value_.copyFrom(values);
        return this;
      }

      @Override
      public MetadataEntry copyFrom(final MetadataEntry other) {
        cachedSize = other.cachedSize;
        if ((bitField0_ | other.bitField0_) != 0) {
          bitField0_ = other.bitField0_;
          if (other.hasKey()) {
            initKey();
            key = other.key;
          } else {
            clearKey();
          }
          if (other.hasValue()) {
            initValue();
            value_.copyFrom(other.value_);
          } else {
            clearValue();
          }
        }
        return this;
      }

      @Override
      public MetadataEntry mergeFrom(final MetadataEntry other) {
        if (other.isEmpty()) {
          return this;
        }
        cachedSize = -1;
        if (other.hasKey()) {
          key = other.key;
        }
        if (other.hasValue()) {
          getMutableValue().copyFrom(other.value_);
        }
        return this;
      }

      @Override
      public MetadataEntry clear() {
        if (isEmpty()) {
          return this;
        }
        cachedSize = -1;
        bitField0_ = 0;
        if (key != null) {
          key = "";
        }
        if (value_ != null) {
          value_ = ByteString.EMPTY;
        }
        return this;
      }

      @Override
      public boolean equals(Object o) {
        if (o == this) {
          return true;
        }
        if (!(o instanceof MetadataEntry)) {
          return false;
        }
        MetadataEntry other = (MetadataEntry) o;
        return bitField0_ == other.bitField0_
          && (!hasKey() || key.equals(other.key))
          && (!hasValue() || value_.equals(other.value_));
      }

      @Override
      public void writeTo(final CodedOutputStream output) throws IOException {
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeRawByte((byte) 10);
          output.writeStringNoTag(key);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeRawByte((byte) 18);
          output.writeBytesNoTag(value_);
        }
      }

      @Override
      protected int computeSerializedSize() {
        int size = 0;
        if ((bitField0_ & 0x00000001) != 0) {
          size += 1 + CodedOutputStream.computeStringSizeNoTag(key);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          size += 1 + CodedOutputStream.computeBytesSizeNoTag(value_);
        }
        return size;
      }

      @Override
      @SuppressWarnings("fallthrough")
      public MetadataEntry mergeFrom(final CodedInputStream input) throws IOException {
        // Enabled Fall-Through Optimization (Quickbuf)
        int tag = input.readTag();
        while (true) {
          switch (tag) {
            case 10: {
              // key
              initKey();
              key = input.readStringRequireUtf8();
              bitField0_ |= 0x00000001;
              tag = input.readTag();
              if (tag != 18) {
                break;
              }
            }
            case 18: {
              // value_
              initValue();
              input.readBytes(value_);
              bitField0_ |= 0x00000002;
              tag = input.readTag();
              if (tag != 0) {
                break;
              }
            }
            case 0: {
              return this;
            }
            default: {
              if (!input.skipField(tag)) {
                return this;
              }
              tag = input.readTag();
              break;
            }
          }
        }
      }

      @Override
      public MetadataEntry clone() {
        return new MetadataEntry().copyFrom(this);
      }

      @Override
      public boolean isEmpty() {
        return ((bitField0_) == 0);
      }

      public static MetadataEntry parseFrom(final byte[] data) throws
          InvalidProtocolBufferException {
        return ProtoMessage.mergeFrom(new MetadataEntry(), data).checkInitialized();
      }

      public static MetadataEntry parseFrom(final CodedInputStream input) throws IOException {
        return ProtoMessage.mergeFrom(new MetadataEntry(), input).checkInitialized();
      }

      /**
       * @return factory for creating MetadataEntry messages
       */
      public static MessageFactory<MetadataEntry> getFactory() {
        return MetadataEntryFactory.INSTANCE;
      }

      private enum MetadataEntryFactory implements MessageFactory<MetadataEntry> {
        INSTANCE;

        @Override
        public MetadataEntry create() {
          return MetadataEntry.newInstance();
        }
      }
    }

    private enum RdfStreamFrameFactory implements MessageFactory<RdfStreamFrame> {
      INSTANCE;

      @Override
      public RdfStreamFrame create() {
        return RdfStreamFrame.newInstance();
      }
    }
  }
}
