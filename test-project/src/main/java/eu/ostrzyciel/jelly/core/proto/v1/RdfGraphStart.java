// Code generated by protocol buffer compiler. Do not edit!
package eu.ostrzyciel.jelly.core.proto.v1;

import com.google.protobuf.CodedInputStream;
import com.google.protobuf.CodedOutputStream;
import com.google.protobuf.InvalidProtocolBufferException;
import eu.neverblink.protoc.java.runtime.MessageFactory;
import eu.neverblink.protoc.java.runtime.ProtoMessage;
import java.io.IOException;

/**
 * Protobuf type {@code RdfGraphStart}
 */
@SuppressWarnings("hiding")
public final class RdfGraphStart extends ProtoMessage<RdfGraphStart> implements Cloneable {
  private static final long serialVersionUID = 0L;

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri g_iri = 1;</code>
   */
  private RdfIri gIri = null;

  /**
   * <code>optional string g_bnode = 2;</code>
   */
  private String gBnode = null;

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfDefaultGraph g_default_graph = 3;</code>
   */
  private RdfDefaultGraph gDefaultGraph = null;

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral g_literal = 4;</code>
   */
  private RdfLiteral gLiteral = null;

  private RdfGraphStart() {
  }

  /**
   * @return a new empty instance of {@code RdfGraphStart}
   */
  public static RdfGraphStart newInstance() {
    return new RdfGraphStart();
  }

  public boolean hasGraph() {
    return (((bitField0_ & 0x0000000f)) != 0);
  }

  public RdfGraphStart clearGraph() {
    if (hasGraph()) {
      clearGIri();
      clearGBnode();
      clearGDefaultGraph();
      clearGLiteral();
    }
    return this;
  }

  private void clearGraphOtherGIri() {
    if ((((bitField0_ & 0x0000000e)) != 0)) {
      clearGBnode();
      clearGDefaultGraph();
      clearGLiteral();
    }
  }

  private void clearGraphOtherGBnode() {
    if ((((bitField0_ & 0x0000000d)) != 0)) {
      clearGIri();
      clearGDefaultGraph();
      clearGLiteral();
    }
  }

  private void clearGraphOtherGDefaultGraph() {
    if ((((bitField0_ & 0x0000000b)) != 0)) {
      clearGIri();
      clearGBnode();
      clearGLiteral();
    }
  }

  private void clearGraphOtherGLiteral() {
    if ((((bitField0_ & 0x00000007)) != 0)) {
      clearGIri();
      clearGBnode();
      clearGDefaultGraph();
    }
  }

  private void initGIri() {
    if (gIri == null) {
      gIri = RdfIri.newInstance();
    }
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri g_iri = 1;</code>
   * @return whether the gIri field is set
   */
  public boolean hasGIri() {
    return (bitField0_ & 0x00000001) != 0;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri g_iri = 1;</code>
   * @return this
   */
  public RdfGraphStart clearGIri() {
    bitField0_ &= ~0x00000001;
    if (gIri != null) {
      gIri.clear();
    }
    return this;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri g_iri = 1;</code>
   *
   * This method returns the internal storage object without modifying any has state.
   * The returned object should not be modified and be treated as read-only.
   *
   * Use {@link #getMutableGIri()} if you want to modify it.
   *
   * @return internal storage object for reading
   */
  public RdfIri getGIri() {
    initGIri();
    return gIri;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri g_iri = 1;</code>
   *
   * This method returns the internal storage object and sets the corresponding
   * has state. The returned object will become part of this message and its
   * contents may be modified as long as the has state is not cleared.
   *
   * @return internal storage object for modifications
   */
  public RdfIri getMutableGIri() {
    clearGraphOtherGIri();
    initGIri();
    bitField0_ |= 0x00000001;
    return gIri;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfIri g_iri = 1;</code>
   * @param value the gIri to set
   * @return this
   */
  public RdfGraphStart setGIri(final RdfIri value) {
    clearGraphOtherGIri();
    initGIri();
    bitField0_ |= 0x00000001;
    gIri.copyFrom(value);
    return this;
  }

  private void initGBnode() {
    if (gBnode == null) {
      gBnode = "";
    }
  }

  /**
   * <code>optional string g_bnode = 2;</code>
   * @return whether the gBnode field is set
   */
  public boolean hasGBnode() {
    return (bitField0_ & 0x00000002) != 0;
  }

  /**
   * <code>optional string g_bnode = 2;</code>
   * @return this
   */
  public RdfGraphStart clearGBnode() {
    bitField0_ &= ~0x00000002;
    if (gBnode != null) {
      gBnode = "";
    }
    return this;
  }

  /**
   * <code>optional string g_bnode = 2;</code>
   * @return the gBnode
   */
  public String getGBnode() {
    initGBnode();
    return gBnode;
  }

  /**
   * <code>optional string g_bnode = 2;</code>
   * @param value the gBnode to set
   * @return this
   */
  public RdfGraphStart setGBnode(final String value) {
    clearGraphOtherGBnode();
    initGBnode();
    bitField0_ |= 0x00000002;
    gBnode = value;
    return this;
  }

  private void initGDefaultGraph() {
    if (gDefaultGraph == null) {
      gDefaultGraph = RdfDefaultGraph.newInstance();
    }
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfDefaultGraph g_default_graph = 3;</code>
   * @return whether the gDefaultGraph field is set
   */
  public boolean hasGDefaultGraph() {
    return (bitField0_ & 0x00000004) != 0;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfDefaultGraph g_default_graph = 3;</code>
   * @return this
   */
  public RdfGraphStart clearGDefaultGraph() {
    bitField0_ &= ~0x00000004;
    if (gDefaultGraph != null) {
      gDefaultGraph.clear();
    }
    return this;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfDefaultGraph g_default_graph = 3;</code>
   *
   * This method returns the internal storage object without modifying any has state.
   * The returned object should not be modified and be treated as read-only.
   *
   * Use {@link #getMutableGDefaultGraph()} if you want to modify it.
   *
   * @return internal storage object for reading
   */
  public RdfDefaultGraph getGDefaultGraph() {
    initGDefaultGraph();
    return gDefaultGraph;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfDefaultGraph g_default_graph = 3;</code>
   *
   * This method returns the internal storage object and sets the corresponding
   * has state. The returned object will become part of this message and its
   * contents may be modified as long as the has state is not cleared.
   *
   * @return internal storage object for modifications
   */
  public RdfDefaultGraph getMutableGDefaultGraph() {
    clearGraphOtherGDefaultGraph();
    initGDefaultGraph();
    bitField0_ |= 0x00000004;
    return gDefaultGraph;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfDefaultGraph g_default_graph = 3;</code>
   * @param value the gDefaultGraph to set
   * @return this
   */
  public RdfGraphStart setGDefaultGraph(final RdfDefaultGraph value) {
    clearGraphOtherGDefaultGraph();
    initGDefaultGraph();
    bitField0_ |= 0x00000004;
    gDefaultGraph.copyFrom(value);
    return this;
  }

  private void initGLiteral() {
    if (gLiteral == null) {
      gLiteral = RdfLiteral.newInstance();
    }
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral g_literal = 4;</code>
   * @return whether the gLiteral field is set
   */
  public boolean hasGLiteral() {
    return (bitField0_ & 0x00000008) != 0;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral g_literal = 4;</code>
   * @return this
   */
  public RdfGraphStart clearGLiteral() {
    bitField0_ &= ~0x00000008;
    if (gLiteral != null) {
      gLiteral.clear();
    }
    return this;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral g_literal = 4;</code>
   *
   * This method returns the internal storage object without modifying any has state.
   * The returned object should not be modified and be treated as read-only.
   *
   * Use {@link #getMutableGLiteral()} if you want to modify it.
   *
   * @return internal storage object for reading
   */
  public RdfLiteral getGLiteral() {
    initGLiteral();
    return gLiteral;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral g_literal = 4;</code>
   *
   * This method returns the internal storage object and sets the corresponding
   * has state. The returned object will become part of this message and its
   * contents may be modified as long as the has state is not cleared.
   *
   * @return internal storage object for modifications
   */
  public RdfLiteral getMutableGLiteral() {
    clearGraphOtherGLiteral();
    initGLiteral();
    bitField0_ |= 0x00000008;
    return gLiteral;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral g_literal = 4;</code>
   * @param value the gLiteral to set
   * @return this
   */
  public RdfGraphStart setGLiteral(final RdfLiteral value) {
    clearGraphOtherGLiteral();
    initGLiteral();
    bitField0_ |= 0x00000008;
    gLiteral.copyFrom(value);
    return this;
  }

  @Override
  public RdfGraphStart copyFrom(final RdfGraphStart other) {
    cachedSize = other.cachedSize;
    if ((bitField0_ | other.bitField0_) != 0) {
      bitField0_ = other.bitField0_;
      if (other.hasGIri()) {
        initGIri();
        gIri.copyFrom(other.gIri);
      } else {
        clearGIri();
      }
      if (other.hasGBnode()) {
        initGBnode();
        gBnode = other.gBnode;
      } else {
        clearGBnode();
      }
      if (other.hasGDefaultGraph()) {
        initGDefaultGraph();
        gDefaultGraph.copyFrom(other.gDefaultGraph);
      } else {
        clearGDefaultGraph();
      }
      if (other.hasGLiteral()) {
        initGLiteral();
        gLiteral.copyFrom(other.gLiteral);
      } else {
        clearGLiteral();
      }
    }
    return this;
  }

  @Override
  public RdfGraphStart mergeFrom(final RdfGraphStart other) {
    if (other.isEmpty()) {
      return this;
    }
    cachedSize = -1;
    if (other.hasGIri()) {
      getMutableGIri().mergeFrom(other.gIri);
    }
    if (other.hasGBnode()) {
      gBnode = other.gBnode;
    }
    if (other.hasGDefaultGraph()) {
      getMutableGDefaultGraph().mergeFrom(other.gDefaultGraph);
    }
    if (other.hasGLiteral()) {
      getMutableGLiteral().mergeFrom(other.gLiteral);
    }
    return this;
  }

  @Override
  public RdfGraphStart clear() {
    if (isEmpty()) {
      return this;
    }
    cachedSize = -1;
    bitField0_ = 0;
    if (gIri != null) {
      gIri.clear();
    }
    if (gBnode != null) {
      gBnode = "";
    }
    if (gDefaultGraph != null) {
      gDefaultGraph.clear();
    }
    if (gLiteral != null) {
      gLiteral.clear();
    }
    return this;
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (!(o instanceof RdfGraphStart)) {
      return false;
    }
    RdfGraphStart other = (RdfGraphStart) o;
    return bitField0_ == other.bitField0_
      && (!hasGIri() || gIri.equals(other.gIri))
      && (!hasGBnode() || gBnode.equals(other.gBnode))
      && (!hasGDefaultGraph() || gDefaultGraph.equals(other.gDefaultGraph))
      && (!hasGLiteral() || gLiteral.equals(other.gLiteral));
  }

  @Override
  public void writeTo(final CodedOutputStream output) throws IOException {
    if ((bitField0_ & 0x00000001) != 0) {
      output.writeRawByte((byte) 10);
      output.writeUInt32NoTag(gIri.getCachedSize());
      gIri.writeTo(output);
    }
    if ((bitField0_ & 0x00000002) != 0) {
      output.writeRawByte((byte) 18);
      output.writeStringNoTag(gBnode);
    }
    if ((bitField0_ & 0x00000004) != 0) {
      output.writeRawByte((byte) 26);
      output.writeUInt32NoTag(gDefaultGraph.getCachedSize());
      gDefaultGraph.writeTo(output);
    }
    if ((bitField0_ & 0x00000008) != 0) {
      output.writeRawByte((byte) 34);
      output.writeUInt32NoTag(gLiteral.getCachedSize());
      gLiteral.writeTo(output);
    }
  }

  @Override
  protected int computeSerializedSize() {
    int size = 0;
    if ((bitField0_ & 0x00000001) != 0) {
      final int dataSize = gIri.getSerializedSize();
      size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
    }
    if ((bitField0_ & 0x00000002) != 0) {
      size += 1 + CodedOutputStream.computeStringSizeNoTag(gBnode);
    }
    if ((bitField0_ & 0x00000004) != 0) {
      final int dataSize = gDefaultGraph.getSerializedSize();
      size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
    }
    if ((bitField0_ & 0x00000008) != 0) {
      final int dataSize = gLiteral.getSerializedSize();
      size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
    }
    return size;
  }

  @Override
  @SuppressWarnings("fallthrough")
  public RdfGraphStart mergeFrom(final CodedInputStream input) throws IOException {
    // Enabled Fall-Through Optimization (Quickbuf)
    int tag = input.readTag();
    while (true) {
      switch (tag) {
        case 10: {
          // gIri
          clearGraphOtherGIri();
          initGIri();
          ProtoMessage.mergeDelimitedFrom(gIri, input);
          bitField0_ |= 0x00000001;
          tag = input.readTag();
          if (tag != 18) {
            break;
          }
        }
        case 18: {
          // gBnode
          clearGraphOtherGBnode();
          initGBnode();
          gBnode = input.readStringRequireUtf8();
          bitField0_ |= 0x00000002;
          tag = input.readTag();
          if (tag != 26) {
            break;
          }
        }
        case 26: {
          // gDefaultGraph
          clearGraphOtherGDefaultGraph();
          initGDefaultGraph();
          ProtoMessage.mergeDelimitedFrom(gDefaultGraph, input);
          bitField0_ |= 0x00000004;
          tag = input.readTag();
          if (tag != 34) {
            break;
          }
        }
        case 34: {
          // gLiteral
          clearGraphOtherGLiteral();
          initGLiteral();
          ProtoMessage.mergeDelimitedFrom(gLiteral, input);
          bitField0_ |= 0x00000008;
          tag = input.readTag();
          if (tag != 0) {
            break;
          }
        }
        case 0: {
          return this;
        }
        default: {
          if (!input.skipField(tag)) {
            return this;
          }
          tag = input.readTag();
          break;
        }
      }
    }
  }

  @Override
  public RdfGraphStart clone() {
    return new RdfGraphStart().copyFrom(this);
  }

  @Override
  public boolean isEmpty() {
    return ((bitField0_) == 0);
  }

  public static RdfGraphStart parseFrom(final byte[] data) throws InvalidProtocolBufferException {
    return ProtoMessage.mergeFrom(new RdfGraphStart(), data).checkInitialized();
  }

  public static RdfGraphStart parseFrom(final CodedInputStream input) throws IOException {
    return ProtoMessage.mergeFrom(new RdfGraphStart(), input).checkInitialized();
  }

  /**
   * @return factory for creating RdfGraphStart messages
   */
  public static MessageFactory<RdfGraphStart> getFactory() {
    return RdfGraphStartFactory.INSTANCE;
  }

  private enum RdfGraphStartFactory implements MessageFactory<RdfGraphStart> {
    INSTANCE;

    @Override
    public RdfGraphStart create() {
      return RdfGraphStart.newInstance();
    }
  }
}
