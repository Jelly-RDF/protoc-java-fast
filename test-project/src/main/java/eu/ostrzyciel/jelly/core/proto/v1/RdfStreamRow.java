// Code generated by protocol buffer compiler. Do not edit!
package eu.ostrzyciel.jelly.core.proto.v1;

import com.google.protobuf.CodedInputStream;
import com.google.protobuf.CodedOutputStream;
import com.google.protobuf.InvalidProtocolBufferException;
import eu.neverblink.protoc.java.runtime.MessageFactory;
import eu.neverblink.protoc.java.runtime.ProtoMessage;
import java.io.IOException;

/**
 * Protobuf type {@code RdfStreamRow}
 */
@SuppressWarnings("hiding")
public final class RdfStreamRow extends ProtoMessage<RdfStreamRow> implements Cloneable {
  private static final long serialVersionUID = 0L;

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfStreamOptions options = 1;</code>
   */
  private RdfStreamOptions options = null;

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple triple = 2;</code>
   */
  private RdfTriple triple = null;

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfQuad quad = 3;</code>
   */
  private RdfQuad quad = null;

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfGraphStart graph_start = 4;</code>
   */
  private RdfGraphStart graphStart = null;

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfGraphEnd graph_end = 5;</code>
   */
  private RdfGraphEnd graphEnd = null;

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfNamespaceDeclaration namespace = 6;</code>
   */
  private RdfNamespaceDeclaration namespace = null;

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfNameEntry name = 9;</code>
   */
  private RdfNameEntry name = null;

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfPrefixEntry prefix = 10;</code>
   */
  private RdfPrefixEntry prefix = null;

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfDatatypeEntry datatype = 11;</code>
   */
  private RdfDatatypeEntry datatype = null;

  private RdfStreamRow() {
  }

  /**
   * @return a new empty instance of {@code RdfStreamRow}
   */
  public static RdfStreamRow newInstance() {
    return new RdfStreamRow();
  }

  public boolean hasRow() {
    return (((bitField0_ & 0x000001ff)) != 0);
  }

  public RdfStreamRow clearRow() {
    if (hasRow()) {
      clearOptions();
      clearTriple();
      clearQuad();
      clearGraphStart();
      clearGraphEnd();
      clearNamespace();
      clearName();
      clearPrefix();
      clearDatatype();
    }
    return this;
  }

  private void clearRowOtherOptions() {
    if ((((bitField0_ & 0x000001fe)) != 0)) {
      clearTriple();
      clearQuad();
      clearGraphStart();
      clearGraphEnd();
      clearNamespace();
      clearName();
      clearPrefix();
      clearDatatype();
    }
  }

  private void clearRowOtherTriple() {
    if ((((bitField0_ & 0x000001fd)) != 0)) {
      clearOptions();
      clearQuad();
      clearGraphStart();
      clearGraphEnd();
      clearNamespace();
      clearName();
      clearPrefix();
      clearDatatype();
    }
  }

  private void clearRowOtherQuad() {
    if ((((bitField0_ & 0x000001fb)) != 0)) {
      clearOptions();
      clearTriple();
      clearGraphStart();
      clearGraphEnd();
      clearNamespace();
      clearName();
      clearPrefix();
      clearDatatype();
    }
  }

  private void clearRowOtherGraphStart() {
    if ((((bitField0_ & 0x000001f7)) != 0)) {
      clearOptions();
      clearTriple();
      clearQuad();
      clearGraphEnd();
      clearNamespace();
      clearName();
      clearPrefix();
      clearDatatype();
    }
  }

  private void clearRowOtherGraphEnd() {
    if ((((bitField0_ & 0x000001ef)) != 0)) {
      clearOptions();
      clearTriple();
      clearQuad();
      clearGraphStart();
      clearNamespace();
      clearName();
      clearPrefix();
      clearDatatype();
    }
  }

  private void clearRowOtherNamespace() {
    if ((((bitField0_ & 0x000001df)) != 0)) {
      clearOptions();
      clearTriple();
      clearQuad();
      clearGraphStart();
      clearGraphEnd();
      clearName();
      clearPrefix();
      clearDatatype();
    }
  }

  private void clearRowOtherName() {
    if ((((bitField0_ & 0x000001bf)) != 0)) {
      clearOptions();
      clearTriple();
      clearQuad();
      clearGraphStart();
      clearGraphEnd();
      clearNamespace();
      clearPrefix();
      clearDatatype();
    }
  }

  private void clearRowOtherPrefix() {
    if ((((bitField0_ & 0x0000017f)) != 0)) {
      clearOptions();
      clearTriple();
      clearQuad();
      clearGraphStart();
      clearGraphEnd();
      clearNamespace();
      clearName();
      clearDatatype();
    }
  }

  private void clearRowOtherDatatype() {
    if ((((bitField0_ & 0x000000ff)) != 0)) {
      clearOptions();
      clearTriple();
      clearQuad();
      clearGraphStart();
      clearGraphEnd();
      clearNamespace();
      clearName();
      clearPrefix();
    }
  }

  private void initOptions() {
    if (options == null) {
      options = RdfStreamOptions.newInstance();
    }
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfStreamOptions options = 1;</code>
   * @return whether the options field is set
   */
  public boolean hasOptions() {
    return (bitField0_ & 0x00000001) != 0;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfStreamOptions options = 1;</code>
   * @return this
   */
  public RdfStreamRow clearOptions() {
    bitField0_ &= ~0x00000001;
    if (options != null) {
      options.clear();
    }
    return this;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfStreamOptions options = 1;</code>
   *
   * This method returns the internal storage object without modifying any has state.
   * The returned object should not be modified and be treated as read-only.
   *
   * Use {@link #getMutableOptions()} if you want to modify it.
   *
   * @return internal storage object for reading
   */
  public RdfStreamOptions getOptions() {
    initOptions();
    return options;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfStreamOptions options = 1;</code>
   *
   * This method returns the internal storage object and sets the corresponding
   * has state. The returned object will become part of this message and its
   * contents may be modified as long as the has state is not cleared.
   *
   * @return internal storage object for modifications
   */
  public RdfStreamOptions getMutableOptions() {
    clearRowOtherOptions();
    initOptions();
    bitField0_ |= 0x00000001;
    return options;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfStreamOptions options = 1;</code>
   * @param value the options to set
   * @return this
   */
  public RdfStreamRow setOptions(final RdfStreamOptions value) {
    clearRowOtherOptions();
    initOptions();
    bitField0_ |= 0x00000001;
    options.copyFrom(value);
    return this;
  }

  private void initTriple() {
    if (triple == null) {
      triple = RdfTriple.newInstance();
    }
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple triple = 2;</code>
   * @return whether the triple field is set
   */
  public boolean hasTriple() {
    return (bitField0_ & 0x00000002) != 0;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple triple = 2;</code>
   * @return this
   */
  public RdfStreamRow clearTriple() {
    bitField0_ &= ~0x00000002;
    if (triple != null) {
      triple.clear();
    }
    return this;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple triple = 2;</code>
   *
   * This method returns the internal storage object without modifying any has state.
   * The returned object should not be modified and be treated as read-only.
   *
   * Use {@link #getMutableTriple()} if you want to modify it.
   *
   * @return internal storage object for reading
   */
  public RdfTriple getTriple() {
    initTriple();
    return triple;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple triple = 2;</code>
   *
   * This method returns the internal storage object and sets the corresponding
   * has state. The returned object will become part of this message and its
   * contents may be modified as long as the has state is not cleared.
   *
   * @return internal storage object for modifications
   */
  public RdfTriple getMutableTriple() {
    clearRowOtherTriple();
    initTriple();
    bitField0_ |= 0x00000002;
    return triple;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfTriple triple = 2;</code>
   * @param value the triple to set
   * @return this
   */
  public RdfStreamRow setTriple(final RdfTriple value) {
    clearRowOtherTriple();
    initTriple();
    bitField0_ |= 0x00000002;
    triple.copyFrom(value);
    return this;
  }

  private void initQuad() {
    if (quad == null) {
      quad = RdfQuad.newInstance();
    }
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfQuad quad = 3;</code>
   * @return whether the quad field is set
   */
  public boolean hasQuad() {
    return (bitField0_ & 0x00000004) != 0;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfQuad quad = 3;</code>
   * @return this
   */
  public RdfStreamRow clearQuad() {
    bitField0_ &= ~0x00000004;
    if (quad != null) {
      quad.clear();
    }
    return this;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfQuad quad = 3;</code>
   *
   * This method returns the internal storage object without modifying any has state.
   * The returned object should not be modified and be treated as read-only.
   *
   * Use {@link #getMutableQuad()} if you want to modify it.
   *
   * @return internal storage object for reading
   */
  public RdfQuad getQuad() {
    initQuad();
    return quad;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfQuad quad = 3;</code>
   *
   * This method returns the internal storage object and sets the corresponding
   * has state. The returned object will become part of this message and its
   * contents may be modified as long as the has state is not cleared.
   *
   * @return internal storage object for modifications
   */
  public RdfQuad getMutableQuad() {
    clearRowOtherQuad();
    initQuad();
    bitField0_ |= 0x00000004;
    return quad;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfQuad quad = 3;</code>
   * @param value the quad to set
   * @return this
   */
  public RdfStreamRow setQuad(final RdfQuad value) {
    clearRowOtherQuad();
    initQuad();
    bitField0_ |= 0x00000004;
    quad.copyFrom(value);
    return this;
  }

  private void initGraphStart() {
    if (graphStart == null) {
      graphStart = RdfGraphStart.newInstance();
    }
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfGraphStart graph_start = 4;</code>
   * @return whether the graphStart field is set
   */
  public boolean hasGraphStart() {
    return (bitField0_ & 0x00000008) != 0;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfGraphStart graph_start = 4;</code>
   * @return this
   */
  public RdfStreamRow clearGraphStart() {
    bitField0_ &= ~0x00000008;
    if (graphStart != null) {
      graphStart.clear();
    }
    return this;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfGraphStart graph_start = 4;</code>
   *
   * This method returns the internal storage object without modifying any has state.
   * The returned object should not be modified and be treated as read-only.
   *
   * Use {@link #getMutableGraphStart()} if you want to modify it.
   *
   * @return internal storage object for reading
   */
  public RdfGraphStart getGraphStart() {
    initGraphStart();
    return graphStart;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfGraphStart graph_start = 4;</code>
   *
   * This method returns the internal storage object and sets the corresponding
   * has state. The returned object will become part of this message and its
   * contents may be modified as long as the has state is not cleared.
   *
   * @return internal storage object for modifications
   */
  public RdfGraphStart getMutableGraphStart() {
    clearRowOtherGraphStart();
    initGraphStart();
    bitField0_ |= 0x00000008;
    return graphStart;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfGraphStart graph_start = 4;</code>
   * @param value the graphStart to set
   * @return this
   */
  public RdfStreamRow setGraphStart(final RdfGraphStart value) {
    clearRowOtherGraphStart();
    initGraphStart();
    bitField0_ |= 0x00000008;
    graphStart.copyFrom(value);
    return this;
  }

  private void initGraphEnd() {
    if (graphEnd == null) {
      graphEnd = RdfGraphEnd.newInstance();
    }
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfGraphEnd graph_end = 5;</code>
   * @return whether the graphEnd field is set
   */
  public boolean hasGraphEnd() {
    return (bitField0_ & 0x00000010) != 0;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfGraphEnd graph_end = 5;</code>
   * @return this
   */
  public RdfStreamRow clearGraphEnd() {
    bitField0_ &= ~0x00000010;
    if (graphEnd != null) {
      graphEnd.clear();
    }
    return this;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfGraphEnd graph_end = 5;</code>
   *
   * This method returns the internal storage object without modifying any has state.
   * The returned object should not be modified and be treated as read-only.
   *
   * Use {@link #getMutableGraphEnd()} if you want to modify it.
   *
   * @return internal storage object for reading
   */
  public RdfGraphEnd getGraphEnd() {
    initGraphEnd();
    return graphEnd;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfGraphEnd graph_end = 5;</code>
   *
   * This method returns the internal storage object and sets the corresponding
   * has state. The returned object will become part of this message and its
   * contents may be modified as long as the has state is not cleared.
   *
   * @return internal storage object for modifications
   */
  public RdfGraphEnd getMutableGraphEnd() {
    clearRowOtherGraphEnd();
    initGraphEnd();
    bitField0_ |= 0x00000010;
    return graphEnd;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfGraphEnd graph_end = 5;</code>
   * @param value the graphEnd to set
   * @return this
   */
  public RdfStreamRow setGraphEnd(final RdfGraphEnd value) {
    clearRowOtherGraphEnd();
    initGraphEnd();
    bitField0_ |= 0x00000010;
    graphEnd.copyFrom(value);
    return this;
  }

  private void initNamespace() {
    if (namespace == null) {
      namespace = RdfNamespaceDeclaration.newInstance();
    }
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfNamespaceDeclaration namespace = 6;</code>
   * @return whether the namespace field is set
   */
  public boolean hasNamespace() {
    return (bitField0_ & 0x00000020) != 0;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfNamespaceDeclaration namespace = 6;</code>
   * @return this
   */
  public RdfStreamRow clearNamespace() {
    bitField0_ &= ~0x00000020;
    if (namespace != null) {
      namespace.clear();
    }
    return this;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfNamespaceDeclaration namespace = 6;</code>
   *
   * This method returns the internal storage object without modifying any has state.
   * The returned object should not be modified and be treated as read-only.
   *
   * Use {@link #getMutableNamespace()} if you want to modify it.
   *
   * @return internal storage object for reading
   */
  public RdfNamespaceDeclaration getNamespace() {
    initNamespace();
    return namespace;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfNamespaceDeclaration namespace = 6;</code>
   *
   * This method returns the internal storage object and sets the corresponding
   * has state. The returned object will become part of this message and its
   * contents may be modified as long as the has state is not cleared.
   *
   * @return internal storage object for modifications
   */
  public RdfNamespaceDeclaration getMutableNamespace() {
    clearRowOtherNamespace();
    initNamespace();
    bitField0_ |= 0x00000020;
    return namespace;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfNamespaceDeclaration namespace = 6;</code>
   * @param value the namespace to set
   * @return this
   */
  public RdfStreamRow setNamespace(final RdfNamespaceDeclaration value) {
    clearRowOtherNamespace();
    initNamespace();
    bitField0_ |= 0x00000020;
    namespace.copyFrom(value);
    return this;
  }

  private void initName() {
    if (name == null) {
      name = RdfNameEntry.newInstance();
    }
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfNameEntry name = 9;</code>
   * @return whether the name field is set
   */
  public boolean hasName() {
    return (bitField0_ & 0x00000040) != 0;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfNameEntry name = 9;</code>
   * @return this
   */
  public RdfStreamRow clearName() {
    bitField0_ &= ~0x00000040;
    if (name != null) {
      name.clear();
    }
    return this;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfNameEntry name = 9;</code>
   *
   * This method returns the internal storage object without modifying any has state.
   * The returned object should not be modified and be treated as read-only.
   *
   * Use {@link #getMutableName()} if you want to modify it.
   *
   * @return internal storage object for reading
   */
  public RdfNameEntry getName() {
    initName();
    return name;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfNameEntry name = 9;</code>
   *
   * This method returns the internal storage object and sets the corresponding
   * has state. The returned object will become part of this message and its
   * contents may be modified as long as the has state is not cleared.
   *
   * @return internal storage object for modifications
   */
  public RdfNameEntry getMutableName() {
    clearRowOtherName();
    initName();
    bitField0_ |= 0x00000040;
    return name;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfNameEntry name = 9;</code>
   * @param value the name to set
   * @return this
   */
  public RdfStreamRow setName(final RdfNameEntry value) {
    clearRowOtherName();
    initName();
    bitField0_ |= 0x00000040;
    name.copyFrom(value);
    return this;
  }

  private void initPrefix() {
    if (prefix == null) {
      prefix = RdfPrefixEntry.newInstance();
    }
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfPrefixEntry prefix = 10;</code>
   * @return whether the prefix field is set
   */
  public boolean hasPrefix() {
    return (bitField0_ & 0x00000080) != 0;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfPrefixEntry prefix = 10;</code>
   * @return this
   */
  public RdfStreamRow clearPrefix() {
    bitField0_ &= ~0x00000080;
    if (prefix != null) {
      prefix.clear();
    }
    return this;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfPrefixEntry prefix = 10;</code>
   *
   * This method returns the internal storage object without modifying any has state.
   * The returned object should not be modified and be treated as read-only.
   *
   * Use {@link #getMutablePrefix()} if you want to modify it.
   *
   * @return internal storage object for reading
   */
  public RdfPrefixEntry getPrefix() {
    initPrefix();
    return prefix;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfPrefixEntry prefix = 10;</code>
   *
   * This method returns the internal storage object and sets the corresponding
   * has state. The returned object will become part of this message and its
   * contents may be modified as long as the has state is not cleared.
   *
   * @return internal storage object for modifications
   */
  public RdfPrefixEntry getMutablePrefix() {
    clearRowOtherPrefix();
    initPrefix();
    bitField0_ |= 0x00000080;
    return prefix;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfPrefixEntry prefix = 10;</code>
   * @param value the prefix to set
   * @return this
   */
  public RdfStreamRow setPrefix(final RdfPrefixEntry value) {
    clearRowOtherPrefix();
    initPrefix();
    bitField0_ |= 0x00000080;
    prefix.copyFrom(value);
    return this;
  }

  private void initDatatype() {
    if (datatype == null) {
      datatype = RdfDatatypeEntry.newInstance();
    }
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfDatatypeEntry datatype = 11;</code>
   * @return whether the datatype field is set
   */
  public boolean hasDatatype() {
    return (bitField0_ & 0x00000100) != 0;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfDatatypeEntry datatype = 11;</code>
   * @return this
   */
  public RdfStreamRow clearDatatype() {
    bitField0_ &= ~0x00000100;
    if (datatype != null) {
      datatype.clear();
    }
    return this;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfDatatypeEntry datatype = 11;</code>
   *
   * This method returns the internal storage object without modifying any has state.
   * The returned object should not be modified and be treated as read-only.
   *
   * Use {@link #getMutableDatatype()} if you want to modify it.
   *
   * @return internal storage object for reading
   */
  public RdfDatatypeEntry getDatatype() {
    initDatatype();
    return datatype;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfDatatypeEntry datatype = 11;</code>
   *
   * This method returns the internal storage object and sets the corresponding
   * has state. The returned object will become part of this message and its
   * contents may be modified as long as the has state is not cleared.
   *
   * @return internal storage object for modifications
   */
  public RdfDatatypeEntry getMutableDatatype() {
    clearRowOtherDatatype();
    initDatatype();
    bitField0_ |= 0x00000100;
    return datatype;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.RdfDatatypeEntry datatype = 11;</code>
   * @param value the datatype to set
   * @return this
   */
  public RdfStreamRow setDatatype(final RdfDatatypeEntry value) {
    clearRowOtherDatatype();
    initDatatype();
    bitField0_ |= 0x00000100;
    datatype.copyFrom(value);
    return this;
  }

  @Override
  public RdfStreamRow copyFrom(final RdfStreamRow other) {
    cachedSize = other.cachedSize;
    if ((bitField0_ | other.bitField0_) != 0) {
      bitField0_ = other.bitField0_;
      if (other.hasOptions()) {
        initOptions();
        options.copyFrom(other.options);
      } else {
        clearOptions();
      }
      if (other.hasTriple()) {
        initTriple();
        triple.copyFrom(other.triple);
      } else {
        clearTriple();
      }
      if (other.hasQuad()) {
        initQuad();
        quad.copyFrom(other.quad);
      } else {
        clearQuad();
      }
      if (other.hasGraphStart()) {
        initGraphStart();
        graphStart.copyFrom(other.graphStart);
      } else {
        clearGraphStart();
      }
      if (other.hasGraphEnd()) {
        initGraphEnd();
        graphEnd.copyFrom(other.graphEnd);
      } else {
        clearGraphEnd();
      }
      if (other.hasNamespace()) {
        initNamespace();
        namespace.copyFrom(other.namespace);
      } else {
        clearNamespace();
      }
      if (other.hasName()) {
        initName();
        name.copyFrom(other.name);
      } else {
        clearName();
      }
      if (other.hasPrefix()) {
        initPrefix();
        prefix.copyFrom(other.prefix);
      } else {
        clearPrefix();
      }
      if (other.hasDatatype()) {
        initDatatype();
        datatype.copyFrom(other.datatype);
      } else {
        clearDatatype();
      }
    }
    return this;
  }

  @Override
  public RdfStreamRow mergeFrom(final RdfStreamRow other) {
    if (other.isEmpty()) {
      return this;
    }
    cachedSize = -1;
    if (other.hasOptions()) {
      getMutableOptions().mergeFrom(other.options);
    }
    if (other.hasTriple()) {
      getMutableTriple().mergeFrom(other.triple);
    }
    if (other.hasQuad()) {
      getMutableQuad().mergeFrom(other.quad);
    }
    if (other.hasGraphStart()) {
      getMutableGraphStart().mergeFrom(other.graphStart);
    }
    if (other.hasGraphEnd()) {
      getMutableGraphEnd().mergeFrom(other.graphEnd);
    }
    if (other.hasNamespace()) {
      getMutableNamespace().mergeFrom(other.namespace);
    }
    if (other.hasName()) {
      getMutableName().mergeFrom(other.name);
    }
    if (other.hasPrefix()) {
      getMutablePrefix().mergeFrom(other.prefix);
    }
    if (other.hasDatatype()) {
      getMutableDatatype().mergeFrom(other.datatype);
    }
    return this;
  }

  @Override
  public RdfStreamRow clear() {
    if (isEmpty()) {
      return this;
    }
    cachedSize = -1;
    bitField0_ = 0;
    if (options != null) {
      options.clear();
    }
    if (triple != null) {
      triple.clear();
    }
    if (quad != null) {
      quad.clear();
    }
    if (graphStart != null) {
      graphStart.clear();
    }
    if (graphEnd != null) {
      graphEnd.clear();
    }
    if (namespace != null) {
      namespace.clear();
    }
    if (name != null) {
      name.clear();
    }
    if (prefix != null) {
      prefix.clear();
    }
    if (datatype != null) {
      datatype.clear();
    }
    return this;
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (!(o instanceof RdfStreamRow)) {
      return false;
    }
    RdfStreamRow other = (RdfStreamRow) o;
    return bitField0_ == other.bitField0_
      && (!hasOptions() || options.equals(other.options))
      && (!hasTriple() || triple.equals(other.triple))
      && (!hasQuad() || quad.equals(other.quad))
      && (!hasGraphStart() || graphStart.equals(other.graphStart))
      && (!hasGraphEnd() || graphEnd.equals(other.graphEnd))
      && (!hasNamespace() || namespace.equals(other.namespace))
      && (!hasName() || name.equals(other.name))
      && (!hasPrefix() || prefix.equals(other.prefix))
      && (!hasDatatype() || datatype.equals(other.datatype));
  }

  @Override
  public void writeTo(final CodedOutputStream output) throws IOException {
    if ((bitField0_ & 0x00000001) != 0) {
      output.writeRawByte((byte) 10);
      output.writeUInt32NoTag(options.getCachedSize());
      options.writeTo(output);
    }
    if ((bitField0_ & 0x00000002) != 0) {
      output.writeRawByte((byte) 18);
      output.writeUInt32NoTag(triple.getCachedSize());
      triple.writeTo(output);
    }
    if ((bitField0_ & 0x00000004) != 0) {
      output.writeRawByte((byte) 26);
      output.writeUInt32NoTag(quad.getCachedSize());
      quad.writeTo(output);
    }
    if ((bitField0_ & 0x00000008) != 0) {
      output.writeRawByte((byte) 34);
      output.writeUInt32NoTag(graphStart.getCachedSize());
      graphStart.writeTo(output);
    }
    if ((bitField0_ & 0x00000010) != 0) {
      output.writeRawByte((byte) 42);
      output.writeUInt32NoTag(graphEnd.getCachedSize());
      graphEnd.writeTo(output);
    }
    if ((bitField0_ & 0x00000020) != 0) {
      output.writeRawByte((byte) 50);
      output.writeUInt32NoTag(namespace.getCachedSize());
      namespace.writeTo(output);
    }
    if ((bitField0_ & 0x00000040) != 0) {
      output.writeRawByte((byte) 74);
      output.writeUInt32NoTag(name.getCachedSize());
      name.writeTo(output);
    }
    if ((bitField0_ & 0x00000080) != 0) {
      output.writeRawByte((byte) 82);
      output.writeUInt32NoTag(prefix.getCachedSize());
      prefix.writeTo(output);
    }
    if ((bitField0_ & 0x00000100) != 0) {
      output.writeRawByte((byte) 90);
      output.writeUInt32NoTag(datatype.getCachedSize());
      datatype.writeTo(output);
    }
  }

  @Override
  protected int computeSerializedSize() {
    int size = 0;
    if ((bitField0_ & 0x00000001) != 0) {
      final int dataSize = options.getSerializedSize();
      size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
    }
    if ((bitField0_ & 0x00000002) != 0) {
      final int dataSize = triple.getSerializedSize();
      size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
    }
    if ((bitField0_ & 0x00000004) != 0) {
      final int dataSize = quad.getSerializedSize();
      size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
    }
    if ((bitField0_ & 0x00000008) != 0) {
      final int dataSize = graphStart.getSerializedSize();
      size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
    }
    if ((bitField0_ & 0x00000010) != 0) {
      final int dataSize = graphEnd.getSerializedSize();
      size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
    }
    if ((bitField0_ & 0x00000020) != 0) {
      final int dataSize = namespace.getSerializedSize();
      size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
    }
    if ((bitField0_ & 0x00000040) != 0) {
      final int dataSize = name.getSerializedSize();
      size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
    }
    if ((bitField0_ & 0x00000080) != 0) {
      final int dataSize = prefix.getSerializedSize();
      size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
    }
    if ((bitField0_ & 0x00000100) != 0) {
      final int dataSize = datatype.getSerializedSize();
      size += 1 + CodedOutputStream.computeUInt32SizeNoTag(dataSize) + dataSize;
    }
    return size;
  }

  @Override
  @SuppressWarnings("fallthrough")
  public RdfStreamRow mergeFrom(final CodedInputStream input) throws IOException {
    // Enabled Fall-Through Optimization (Quickbuf)
    int tag = input.readTag();
    while (true) {
      switch (tag) {
        case 10: {
          // options
          clearRowOtherOptions();
          initOptions();
          ProtoMessage.mergeDelimitedFrom(options, input);
          bitField0_ |= 0x00000001;
          tag = input.readTag();
          if (tag != 18) {
            break;
          }
        }
        case 18: {
          // triple
          clearRowOtherTriple();
          initTriple();
          ProtoMessage.mergeDelimitedFrom(triple, input);
          bitField0_ |= 0x00000002;
          tag = input.readTag();
          if (tag != 26) {
            break;
          }
        }
        case 26: {
          // quad
          clearRowOtherQuad();
          initQuad();
          ProtoMessage.mergeDelimitedFrom(quad, input);
          bitField0_ |= 0x00000004;
          tag = input.readTag();
          if (tag != 34) {
            break;
          }
        }
        case 34: {
          // graphStart
          clearRowOtherGraphStart();
          initGraphStart();
          ProtoMessage.mergeDelimitedFrom(graphStart, input);
          bitField0_ |= 0x00000008;
          tag = input.readTag();
          if (tag != 42) {
            break;
          }
        }
        case 42: {
          // graphEnd
          clearRowOtherGraphEnd();
          initGraphEnd();
          ProtoMessage.mergeDelimitedFrom(graphEnd, input);
          bitField0_ |= 0x00000010;
          tag = input.readTag();
          if (tag != 50) {
            break;
          }
        }
        case 50: {
          // namespace
          clearRowOtherNamespace();
          initNamespace();
          ProtoMessage.mergeDelimitedFrom(namespace, input);
          bitField0_ |= 0x00000020;
          tag = input.readTag();
          if (tag != 74) {
            break;
          }
        }
        case 74: {
          // name
          clearRowOtherName();
          initName();
          ProtoMessage.mergeDelimitedFrom(name, input);
          bitField0_ |= 0x00000040;
          tag = input.readTag();
          if (tag != 82) {
            break;
          }
        }
        case 82: {
          // prefix
          clearRowOtherPrefix();
          initPrefix();
          ProtoMessage.mergeDelimitedFrom(prefix, input);
          bitField0_ |= 0x00000080;
          tag = input.readTag();
          if (tag != 90) {
            break;
          }
        }
        case 90: {
          // datatype
          clearRowOtherDatatype();
          initDatatype();
          ProtoMessage.mergeDelimitedFrom(datatype, input);
          bitField0_ |= 0x00000100;
          tag = input.readTag();
          if (tag != 0) {
            break;
          }
        }
        case 0: {
          return this;
        }
        default: {
          if (!input.skipField(tag)) {
            return this;
          }
          tag = input.readTag();
          break;
        }
      }
    }
  }

  @Override
  public RdfStreamRow clone() {
    return new RdfStreamRow().copyFrom(this);
  }

  @Override
  public boolean isEmpty() {
    return ((bitField0_) == 0);
  }

  public static RdfStreamRow parseFrom(final byte[] data) throws InvalidProtocolBufferException {
    return ProtoMessage.mergeFrom(new RdfStreamRow(), data).checkInitialized();
  }

  public static RdfStreamRow parseFrom(final CodedInputStream input) throws IOException {
    return ProtoMessage.mergeFrom(new RdfStreamRow(), input).checkInitialized();
  }

  /**
   * @return factory for creating RdfStreamRow messages
   */
  public static MessageFactory<RdfStreamRow> getFactory() {
    return RdfStreamRowFactory.INSTANCE;
  }

  private enum RdfStreamRowFactory implements MessageFactory<RdfStreamRow> {
    INSTANCE;

    @Override
    public RdfStreamRow create() {
      return RdfStreamRow.newInstance();
    }
  }
}
