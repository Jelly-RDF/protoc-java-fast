// Code generated by protocol buffer compiler. Do not edit!
package eu.ostrzyciel.jelly.core.proto.v1;

import com.google.protobuf.CodedInputStream;
import com.google.protobuf.CodedOutputStream;
import com.google.protobuf.InvalidProtocolBufferException;
import eu.neverblink.protoc.java.runtime.MessageFactory;
import eu.neverblink.protoc.java.runtime.ProtoMessage;
import java.io.IOException;

/**
 * Protobuf type {@code RdfStreamOptions}
 */
@SuppressWarnings("hiding")
public final class RdfStreamOptions extends ProtoMessage<RdfStreamOptions> implements Cloneable {
  private static final long serialVersionUID = 0L;

  /**
   * <code>optional string stream_name = 1;</code>
   */
  private String streamName = null;

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.PhysicalStreamType physical_type = 2;</code>
   */
  private int physicalType;

  /**
   * <code>optional bool generalized_statements = 3;</code>
   */
  private boolean generalizedStatements;

  /**
   * <code>optional bool rdf_star = 4;</code>
   */
  private boolean rdfStar;

  /**
   * <code>optional uint32 max_name_table_size = 9;</code>
   */
  private int maxNameTableSize;

  /**
   * <code>optional uint32 max_prefix_table_size = 10;</code>
   */
  private int maxPrefixTableSize;

  /**
   * <code>optional uint32 max_datatype_table_size = 11;</code>
   */
  private int maxDatatypeTableSize;

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.LogicalStreamType logical_type = 14;</code>
   */
  private int logicalType;

  /**
   * <code>optional uint32 version = 15;</code>
   */
  private int version;

  private RdfStreamOptions() {
  }

  /**
   * @return a new empty instance of {@code RdfStreamOptions}
   */
  public static RdfStreamOptions newInstance() {
    return new RdfStreamOptions();
  }

  private void initStreamName() {
    if (streamName == null) {
      streamName = "";
    }
  }

  /**
   * <code>optional string stream_name = 1;</code>
   * @return whether the streamName field is set
   */
  public boolean hasStreamName() {
    return (bitField0_ & 0x00000001) != 0;
  }

  /**
   * <code>optional string stream_name = 1;</code>
   * @return this
   */
  public RdfStreamOptions clearStreamName() {
    bitField0_ &= ~0x00000001;
    if (streamName != null) {
      streamName = "";
    }
    return this;
  }

  /**
   * <code>optional string stream_name = 1;</code>
   * @return the streamName
   */
  public String getStreamName() {
    initStreamName();
    return streamName;
  }

  /**
   * <code>optional string stream_name = 1;</code>
   * @param value the streamName to set
   * @return this
   */
  public RdfStreamOptions setStreamName(final String value) {
    initStreamName();
    bitField0_ |= 0x00000001;
    streamName = value;
    return this;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.PhysicalStreamType physical_type = 2;</code>
   * @return whether the physicalType field is set
   */
  public boolean hasPhysicalType() {
    return (bitField0_ & 0x00000002) != 0;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.PhysicalStreamType physical_type = 2;</code>
   * @return this
   */
  public RdfStreamOptions clearPhysicalType() {
    bitField0_ &= ~0x00000002;
    physicalType = 0;
    return this;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.PhysicalStreamType physical_type = 2;</code>
   * @return the physicalType
   */
  public PhysicalStreamType getPhysicalType() {
    return PhysicalStreamType.forNumber(physicalType);
  }

  /**
   * Gets the value of the internal enum store. The result is
   * equivalent to {@link RdfStreamOptions#getPhysicalType()}.getNumber().
   *
   * @return numeric wire representation
   */
  public int getPhysicalTypeValue() {
    return physicalType;
  }

  /**
   * Sets the value of the internal enum store. This does not
   * do any validity checks, so be sure to use appropriate value
   * constants from {@link PhysicalStreamType}. Setting an invalid value
   * can cause {@link RdfStreamOptions#getPhysicalType()} to return null
   *
   * @param value the numeric wire value to set
   * @return this
   */
  public RdfStreamOptions setPhysicalTypeValue(final int value) {
    bitField0_ |= 0x00000002;
    physicalType = value;
    return this;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.PhysicalStreamType physical_type = 2;</code>
   * @param value the physicalType to set
   * @return this
   */
  public RdfStreamOptions setPhysicalType(final PhysicalStreamType value) {
    bitField0_ |= 0x00000002;
    physicalType = value.getNumber();
    return this;
  }

  /**
   * <code>optional bool generalized_statements = 3;</code>
   * @return whether the generalizedStatements field is set
   */
  public boolean hasGeneralizedStatements() {
    return (bitField0_ & 0x00000004) != 0;
  }

  /**
   * <code>optional bool generalized_statements = 3;</code>
   * @return this
   */
  public RdfStreamOptions clearGeneralizedStatements() {
    bitField0_ &= ~0x00000004;
    generalizedStatements = false;
    return this;
  }

  /**
   * <code>optional bool generalized_statements = 3;</code>
   * @return the generalizedStatements
   */
  public boolean getGeneralizedStatements() {
    return generalizedStatements;
  }

  /**
   * <code>optional bool generalized_statements = 3;</code>
   * @param value the generalizedStatements to set
   * @return this
   */
  public RdfStreamOptions setGeneralizedStatements(final boolean value) {
    bitField0_ |= 0x00000004;
    generalizedStatements = value;
    return this;
  }

  /**
   * <code>optional bool rdf_star = 4;</code>
   * @return whether the rdfStar field is set
   */
  public boolean hasRdfStar() {
    return (bitField0_ & 0x00000008) != 0;
  }

  /**
   * <code>optional bool rdf_star = 4;</code>
   * @return this
   */
  public RdfStreamOptions clearRdfStar() {
    bitField0_ &= ~0x00000008;
    rdfStar = false;
    return this;
  }

  /**
   * <code>optional bool rdf_star = 4;</code>
   * @return the rdfStar
   */
  public boolean getRdfStar() {
    return rdfStar;
  }

  /**
   * <code>optional bool rdf_star = 4;</code>
   * @param value the rdfStar to set
   * @return this
   */
  public RdfStreamOptions setRdfStar(final boolean value) {
    bitField0_ |= 0x00000008;
    rdfStar = value;
    return this;
  }

  /**
   * <code>optional uint32 max_name_table_size = 9;</code>
   * @return whether the maxNameTableSize field is set
   */
  public boolean hasMaxNameTableSize() {
    return (bitField0_ & 0x00000010) != 0;
  }

  /**
   * <code>optional uint32 max_name_table_size = 9;</code>
   * @return this
   */
  public RdfStreamOptions clearMaxNameTableSize() {
    bitField0_ &= ~0x00000010;
    maxNameTableSize = 0;
    return this;
  }

  /**
   * <code>optional uint32 max_name_table_size = 9;</code>
   * @return the maxNameTableSize
   */
  public int getMaxNameTableSize() {
    return maxNameTableSize;
  }

  /**
   * <code>optional uint32 max_name_table_size = 9;</code>
   * @param value the maxNameTableSize to set
   * @return this
   */
  public RdfStreamOptions setMaxNameTableSize(final int value) {
    bitField0_ |= 0x00000010;
    maxNameTableSize = value;
    return this;
  }

  /**
   * <code>optional uint32 max_prefix_table_size = 10;</code>
   * @return whether the maxPrefixTableSize field is set
   */
  public boolean hasMaxPrefixTableSize() {
    return (bitField0_ & 0x00000020) != 0;
  }

  /**
   * <code>optional uint32 max_prefix_table_size = 10;</code>
   * @return this
   */
  public RdfStreamOptions clearMaxPrefixTableSize() {
    bitField0_ &= ~0x00000020;
    maxPrefixTableSize = 0;
    return this;
  }

  /**
   * <code>optional uint32 max_prefix_table_size = 10;</code>
   * @return the maxPrefixTableSize
   */
  public int getMaxPrefixTableSize() {
    return maxPrefixTableSize;
  }

  /**
   * <code>optional uint32 max_prefix_table_size = 10;</code>
   * @param value the maxPrefixTableSize to set
   * @return this
   */
  public RdfStreamOptions setMaxPrefixTableSize(final int value) {
    bitField0_ |= 0x00000020;
    maxPrefixTableSize = value;
    return this;
  }

  /**
   * <code>optional uint32 max_datatype_table_size = 11;</code>
   * @return whether the maxDatatypeTableSize field is set
   */
  public boolean hasMaxDatatypeTableSize() {
    return (bitField0_ & 0x00000040) != 0;
  }

  /**
   * <code>optional uint32 max_datatype_table_size = 11;</code>
   * @return this
   */
  public RdfStreamOptions clearMaxDatatypeTableSize() {
    bitField0_ &= ~0x00000040;
    maxDatatypeTableSize = 0;
    return this;
  }

  /**
   * <code>optional uint32 max_datatype_table_size = 11;</code>
   * @return the maxDatatypeTableSize
   */
  public int getMaxDatatypeTableSize() {
    return maxDatatypeTableSize;
  }

  /**
   * <code>optional uint32 max_datatype_table_size = 11;</code>
   * @param value the maxDatatypeTableSize to set
   * @return this
   */
  public RdfStreamOptions setMaxDatatypeTableSize(final int value) {
    bitField0_ |= 0x00000040;
    maxDatatypeTableSize = value;
    return this;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.LogicalStreamType logical_type = 14;</code>
   * @return whether the logicalType field is set
   */
  public boolean hasLogicalType() {
    return (bitField0_ & 0x00000080) != 0;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.LogicalStreamType logical_type = 14;</code>
   * @return this
   */
  public RdfStreamOptions clearLogicalType() {
    bitField0_ &= ~0x00000080;
    logicalType = 0;
    return this;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.LogicalStreamType logical_type = 14;</code>
   * @return the logicalType
   */
  public LogicalStreamType getLogicalType() {
    return LogicalStreamType.forNumber(logicalType);
  }

  /**
   * Gets the value of the internal enum store. The result is
   * equivalent to {@link RdfStreamOptions#getLogicalType()}.getNumber().
   *
   * @return numeric wire representation
   */
  public int getLogicalTypeValue() {
    return logicalType;
  }

  /**
   * Sets the value of the internal enum store. This does not
   * do any validity checks, so be sure to use appropriate value
   * constants from {@link LogicalStreamType}. Setting an invalid value
   * can cause {@link RdfStreamOptions#getLogicalType()} to return null
   *
   * @param value the numeric wire value to set
   * @return this
   */
  public RdfStreamOptions setLogicalTypeValue(final int value) {
    bitField0_ |= 0x00000080;
    logicalType = value;
    return this;
  }

  /**
   * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.LogicalStreamType logical_type = 14;</code>
   * @param value the logicalType to set
   * @return this
   */
  public RdfStreamOptions setLogicalType(final LogicalStreamType value) {
    bitField0_ |= 0x00000080;
    logicalType = value.getNumber();
    return this;
  }

  /**
   * <code>optional uint32 version = 15;</code>
   * @return whether the version field is set
   */
  public boolean hasVersion() {
    return (bitField0_ & 0x00000100) != 0;
  }

  /**
   * <code>optional uint32 version = 15;</code>
   * @return this
   */
  public RdfStreamOptions clearVersion() {
    bitField0_ &= ~0x00000100;
    version = 0;
    return this;
  }

  /**
   * <code>optional uint32 version = 15;</code>
   * @return the version
   */
  public int getVersion() {
    return version;
  }

  /**
   * <code>optional uint32 version = 15;</code>
   * @param value the version to set
   * @return this
   */
  public RdfStreamOptions setVersion(final int value) {
    bitField0_ |= 0x00000100;
    version = value;
    return this;
  }

  @Override
  public RdfStreamOptions copyFrom(final RdfStreamOptions other) {
    cachedSize = other.cachedSize;
    if ((bitField0_ | other.bitField0_) != 0) {
      bitField0_ = other.bitField0_;
      if (other.hasStreamName()) {
        initStreamName();
        streamName = other.streamName;
      } else {
        clearStreamName();
      }
      physicalType = other.physicalType;
      generalizedStatements = other.generalizedStatements;
      rdfStar = other.rdfStar;
      maxNameTableSize = other.maxNameTableSize;
      maxPrefixTableSize = other.maxPrefixTableSize;
      maxDatatypeTableSize = other.maxDatatypeTableSize;
      logicalType = other.logicalType;
      version = other.version;
    }
    return this;
  }

  @Override
  public RdfStreamOptions mergeFrom(final RdfStreamOptions other) {
    if (other.isEmpty()) {
      return this;
    }
    cachedSize = -1;
    if (other.hasStreamName()) {
      streamName = other.streamName;
    }
    if (other.hasPhysicalType()) {
      setPhysicalTypeValue(other.physicalType);
    }
    if (other.hasGeneralizedStatements()) {
      setGeneralizedStatements(other.generalizedStatements);
    }
    if (other.hasRdfStar()) {
      setRdfStar(other.rdfStar);
    }
    if (other.hasMaxNameTableSize()) {
      setMaxNameTableSize(other.maxNameTableSize);
    }
    if (other.hasMaxPrefixTableSize()) {
      setMaxPrefixTableSize(other.maxPrefixTableSize);
    }
    if (other.hasMaxDatatypeTableSize()) {
      setMaxDatatypeTableSize(other.maxDatatypeTableSize);
    }
    if (other.hasLogicalType()) {
      setLogicalTypeValue(other.logicalType);
    }
    if (other.hasVersion()) {
      setVersion(other.version);
    }
    return this;
  }

  @Override
  public RdfStreamOptions clear() {
    if (isEmpty()) {
      return this;
    }
    cachedSize = -1;
    bitField0_ = 0;
    if (streamName != null) {
      streamName = "";
    }
    physicalType = 0;
    generalizedStatements = false;
    rdfStar = false;
    maxNameTableSize = 0;
    maxPrefixTableSize = 0;
    maxDatatypeTableSize = 0;
    logicalType = 0;
    version = 0;
    return this;
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (!(o instanceof RdfStreamOptions)) {
      return false;
    }
    RdfStreamOptions other = (RdfStreamOptions) o;
    return bitField0_ == other.bitField0_
      && (!hasStreamName() || streamName.equals(other.streamName))
      && (!hasPhysicalType() || physicalType == other.physicalType)
      && (!hasGeneralizedStatements() || generalizedStatements == other.generalizedStatements)
      && (!hasRdfStar() || rdfStar == other.rdfStar)
      && (!hasMaxNameTableSize() || maxNameTableSize == other.maxNameTableSize)
      && (!hasMaxPrefixTableSize() || maxPrefixTableSize == other.maxPrefixTableSize)
      && (!hasMaxDatatypeTableSize() || maxDatatypeTableSize == other.maxDatatypeTableSize)
      && (!hasLogicalType() || logicalType == other.logicalType)
      && (!hasVersion() || version == other.version);
  }

  @Override
  public void writeTo(final CodedOutputStream output) throws IOException {
    if ((bitField0_ & 0x00000001) != 0) {
      output.writeRawByte((byte) 10);
      output.writeStringNoTag(streamName);
    }
    if ((bitField0_ & 0x00000002) != 0) {
      output.writeRawByte((byte) 16);
      output.writeEnumNoTag(physicalType);
    }
    if ((bitField0_ & 0x00000004) != 0) {
      output.writeRawByte((byte) 24);
      output.writeBoolNoTag(generalizedStatements);
    }
    if ((bitField0_ & 0x00000008) != 0) {
      output.writeRawByte((byte) 32);
      output.writeBoolNoTag(rdfStar);
    }
    if ((bitField0_ & 0x00000010) != 0) {
      output.writeRawByte((byte) 72);
      output.writeUInt32NoTag(maxNameTableSize);
    }
    if ((bitField0_ & 0x00000020) != 0) {
      output.writeRawByte((byte) 80);
      output.writeUInt32NoTag(maxPrefixTableSize);
    }
    if ((bitField0_ & 0x00000040) != 0) {
      output.writeRawByte((byte) 88);
      output.writeUInt32NoTag(maxDatatypeTableSize);
    }
    if ((bitField0_ & 0x00000080) != 0) {
      output.writeRawByte((byte) 112);
      output.writeEnumNoTag(logicalType);
    }
    if ((bitField0_ & 0x00000100) != 0) {
      output.writeRawByte((byte) 120);
      output.writeUInt32NoTag(version);
    }
  }

  @Override
  protected int computeSerializedSize() {
    int size = 0;
    if ((bitField0_ & 0x00000001) != 0) {
      size += 1 + CodedOutputStream.computeStringSizeNoTag(streamName);
    }
    if ((bitField0_ & 0x00000002) != 0) {
      size += 1 + CodedOutputStream.computeEnumSizeNoTag(physicalType);
    }
    if ((bitField0_ & 0x00000004) != 0) {
      size += 2;
    }
    if ((bitField0_ & 0x00000008) != 0) {
      size += 2;
    }
    if ((bitField0_ & 0x00000010) != 0) {
      size += 1 + CodedOutputStream.computeUInt32SizeNoTag(maxNameTableSize);
    }
    if ((bitField0_ & 0x00000020) != 0) {
      size += 1 + CodedOutputStream.computeUInt32SizeNoTag(maxPrefixTableSize);
    }
    if ((bitField0_ & 0x00000040) != 0) {
      size += 1 + CodedOutputStream.computeUInt32SizeNoTag(maxDatatypeTableSize);
    }
    if ((bitField0_ & 0x00000080) != 0) {
      size += 1 + CodedOutputStream.computeEnumSizeNoTag(logicalType);
    }
    if ((bitField0_ & 0x00000100) != 0) {
      size += 1 + CodedOutputStream.computeUInt32SizeNoTag(version);
    }
    return size;
  }

  @Override
  @SuppressWarnings("fallthrough")
  public RdfStreamOptions mergeFrom(final CodedInputStream input) throws IOException {
    // Enabled Fall-Through Optimization (Quickbuf)
    int tag = input.readTag();
    while (true) {
      switch (tag) {
        case 10: {
          // streamName
          initStreamName();
          streamName = input.readStringRequireUtf8();
          bitField0_ |= 0x00000001;
          tag = input.readTag();
          if (tag != 16) {
            break;
          }
        }
        case 16: {
          // physicalType
          final int value = input.readInt32();
          if (PhysicalStreamType.forNumber(value) != null) {
            physicalType = value;
            bitField0_ |= 0x00000002;
          }
          tag = input.readTag();
          if (tag != 24) {
            break;
          }
        }
        case 24: {
          // generalizedStatements
          generalizedStatements = input.readBool();
          bitField0_ |= 0x00000004;
          tag = input.readTag();
          if (tag != 32) {
            break;
          }
        }
        case 32: {
          // rdfStar
          rdfStar = input.readBool();
          bitField0_ |= 0x00000008;
          tag = input.readTag();
          if (tag != 72) {
            break;
          }
        }
        case 72: {
          // maxNameTableSize
          maxNameTableSize = input.readUInt32();
          bitField0_ |= 0x00000010;
          tag = input.readTag();
          if (tag != 80) {
            break;
          }
        }
        case 80: {
          // maxPrefixTableSize
          maxPrefixTableSize = input.readUInt32();
          bitField0_ |= 0x00000020;
          tag = input.readTag();
          if (tag != 88) {
            break;
          }
        }
        case 88: {
          // maxDatatypeTableSize
          maxDatatypeTableSize = input.readUInt32();
          bitField0_ |= 0x00000040;
          tag = input.readTag();
          if (tag != 112) {
            break;
          }
        }
        case 112: {
          // logicalType
          final int value = input.readInt32();
          if (LogicalStreamType.forNumber(value) != null) {
            logicalType = value;
            bitField0_ |= 0x00000080;
          }
          tag = input.readTag();
          if (tag != 120) {
            break;
          }
        }
        case 120: {
          // version
          version = input.readUInt32();
          bitField0_ |= 0x00000100;
          tag = input.readTag();
          if (tag != 0) {
            break;
          }
        }
        case 0: {
          return this;
        }
        default: {
          if (!input.skipField(tag)) {
            return this;
          }
          tag = input.readTag();
          break;
        }
      }
    }
  }

  @Override
  public RdfStreamOptions clone() {
    return new RdfStreamOptions().copyFrom(this);
  }

  @Override
  public boolean isEmpty() {
    return ((bitField0_) == 0);
  }

  public static RdfStreamOptions parseFrom(final byte[] data) throws
      InvalidProtocolBufferException {
    return ProtoMessage.mergeFrom(new RdfStreamOptions(), data).checkInitialized();
  }

  public static RdfStreamOptions parseFrom(final CodedInputStream input) throws IOException {
    return ProtoMessage.mergeFrom(new RdfStreamOptions(), input).checkInitialized();
  }

  /**
   * @return factory for creating RdfStreamOptions messages
   */
  public static MessageFactory<RdfStreamOptions> getFactory() {
    return RdfStreamOptionsFactory.INSTANCE;
  }

  private enum RdfStreamOptionsFactory implements MessageFactory<RdfStreamOptions> {
    INSTANCE;

    @Override
    public RdfStreamOptions create() {
      return RdfStreamOptions.newInstance();
    }
  }
}
