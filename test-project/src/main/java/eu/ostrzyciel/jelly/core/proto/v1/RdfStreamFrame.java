// Code generated by protocol buffer compiler. Do not edit!
package eu.ostrzyciel.jelly.core.proto.v1;

import com.google.protobuf.ByteString;
import com.google.protobuf.CodedInputStream;
import com.google.protobuf.CodedOutputStream;
import com.google.protobuf.InvalidProtocolBufferException;
import eu.neverblink.protoc.java.runtime.MessageFactory;
import eu.neverblink.protoc.java.runtime.ProtoMessage;
import java.io.IOException;
import java.util.Collections;
import java.util.List;

/**
 * Protobuf type {@code RdfStreamFrame}
 */
@SuppressWarnings("hiding")
public final class RdfStreamFrame extends ProtoMessage<RdfStreamFrame> implements Cloneable {
  /**
   * <code>repeated .eu.ostrzyciel.jelly.core.proto.v1.RdfStreamRow rows = 1;</code>
   */
  private List<RdfStreamRow> rows = null;

  /**
   * <code>repeated .eu.ostrzyciel.jelly.core.proto.v1.RdfStreamFrame.MetadataEntry metadata = 15;</code>
   */
  private List<MetadataEntry> metadata = null;

  private RdfStreamFrame() {
  }

  /**
   * @return a new empty instance of {@code RdfStreamFrame}
   */
  public static RdfStreamFrame newInstance() {
    return new RdfStreamFrame();
  }

  private void initRows() {
    if (rows == null) {
      rows = Collections.emptyList();
    }
  }

  /**
   * <code>repeated .eu.ostrzyciel.jelly.core.proto.v1.RdfStreamRow rows = 1;</code>
   * @return whether the rows field is set
   */
  public boolean hasRows() {
    return (bitField0_ & 0x00000001) != 0;
  }

  /**
   * <code>repeated .eu.ostrzyciel.jelly.core.proto.v1.RdfStreamRow rows = 1;</code>
   * @return this
   */
  public RdfStreamFrame clearRows() {
    bitField0_ &= ~0x00000001;
    if (rows != null) {
      rows.clear();
    }
    return this;
  }

  /**
   * <code>repeated .eu.ostrzyciel.jelly.core.proto.v1.RdfStreamRow rows = 1;</code>
   *
   * This method returns the internal storage object without modifying any has state.
   * The returned object should not be modified and be treated as read-only.
   *
   * Use {@link #getMutableRows()} if you want to modify it.
   *
   * @return internal storage object for reading
   */
  public List<RdfStreamRow> getRows() {
    initRows();
    return rows;
  }

  /**
   * <code>repeated .eu.ostrzyciel.jelly.core.proto.v1.RdfStreamRow rows = 1;</code>
   *
   * This method returns the internal storage object and sets the corresponding
   * has state. The returned object will become part of this message and its
   * contents may be modified as long as the has state is not cleared.
   *
   * @return internal storage object for modifications
   */
  public List<RdfStreamRow> getMutableRows() {
    initRows();
    bitField0_ |= 0x00000001;
    return rows;
  }

  /**
   * <code>repeated .eu.ostrzyciel.jelly.core.proto.v1.RdfStreamRow rows = 1;</code>
   * @param value the rows to add
   * @return this
   */
  public RdfStreamFrame addRows(final RdfStreamRow value) {
    initRows();
    bitField0_ |= 0x00000001;
    rows.add(value);
    return this;
  }

  private void initMetadata() {
    if (metadata == null) {
      metadata = Collections.emptyList();
    }
  }

  /**
   * <code>repeated .eu.ostrzyciel.jelly.core.proto.v1.RdfStreamFrame.MetadataEntry metadata = 15;</code>
   * @return whether the metadata field is set
   */
  public boolean hasMetadata() {
    return (bitField0_ & 0x00000002) != 0;
  }

  /**
   * <code>repeated .eu.ostrzyciel.jelly.core.proto.v1.RdfStreamFrame.MetadataEntry metadata = 15;</code>
   * @return this
   */
  public RdfStreamFrame clearMetadata() {
    bitField0_ &= ~0x00000002;
    if (metadata != null) {
      metadata.clear();
    }
    return this;
  }

  /**
   * <code>repeated .eu.ostrzyciel.jelly.core.proto.v1.RdfStreamFrame.MetadataEntry metadata = 15;</code>
   *
   * This method returns the internal storage object without modifying any has state.
   * The returned object should not be modified and be treated as read-only.
   *
   * Use {@link #getMutableMetadata()} if you want to modify it.
   *
   * @return internal storage object for reading
   */
  public List<MetadataEntry> getMetadata() {
    initMetadata();
    return metadata;
  }

  /**
   * <code>repeated .eu.ostrzyciel.jelly.core.proto.v1.RdfStreamFrame.MetadataEntry metadata = 15;</code>
   *
   * This method returns the internal storage object and sets the corresponding
   * has state. The returned object will become part of this message and its
   * contents may be modified as long as the has state is not cleared.
   *
   * @return internal storage object for modifications
   */
  public List<MetadataEntry> getMutableMetadata() {
    initMetadata();
    bitField0_ |= 0x00000002;
    return metadata;
  }

  /**
   * <code>repeated .eu.ostrzyciel.jelly.core.proto.v1.RdfStreamFrame.MetadataEntry metadata = 15;</code>
   * @param value the metadata to add
   * @return this
   */
  public RdfStreamFrame addMetadata(final MetadataEntry value) {
    initMetadata();
    bitField0_ |= 0x00000002;
    metadata.add(value);
    return this;
  }

  @Override
  public RdfStreamFrame copyFrom(final RdfStreamFrame other) {
    cachedSize = other.cachedSize;
    if ((bitField0_ | other.bitField0_) != 0) {
      bitField0_ = other.bitField0_;
      if (other.hasRows()) {
        initRows();
        rows.addAll(other.rows);
      } else {
        clearRows();
      }
      if (other.hasMetadata()) {
        initMetadata();
        metadata.addAll(other.metadata);
      } else {
        clearMetadata();
      }
    }
    return this;
  }

  @Override
  public RdfStreamFrame mergeFrom(final RdfStreamFrame other) {
    if (other.isEmpty()) {
      return this;
    }
    cachedSize = -1;
    if (other.hasRows()) {
      getMutableRows().addAll(other.rows);
    }
    if (other.hasMetadata()) {
      getMutableMetadata().addAll(other.metadata);
    }
    return this;
  }

  @Override
  public RdfStreamFrame clear() {
    if (isEmpty()) {
      return this;
    }
    cachedSize = -1;
    bitField0_ = 0;
    if (rows != null) {
      rows.clear();
    }
    if (metadata != null) {
      metadata.clear();
    }
    return this;
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (!(o instanceof RdfStreamFrame)) {
      return false;
    }
    RdfStreamFrame other = (RdfStreamFrame) o;
    return bitField0_ == other.bitField0_
      && (!hasRows() || rows.equals(other.rows))
      && (!hasMetadata() || metadata.equals(other.metadata));
  }

  @Override
  public void writeTo(final CodedOutputStream output) throws IOException {
    if ((bitField0_ & 0x00000001) != 0) {
      for (final var _field : rows) {
        output.writeRawByte((byte) 10);
        output.writeUInt32NoTag(_field.getCachedSize());
        _field.writeTo(output);
      }
    }
    if ((bitField0_ & 0x00000002) != 0) {
      for (final var _field : metadata) {
        output.writeRawByte((byte) 122);
        output.writeUInt32NoTag(_field.getCachedSize());
        _field.writeTo(output);
      }
    }
  }

  @Override
  protected int computeSerializedSize() {
    int size = 0;
    if ((bitField0_ & 0x00000001) != 0) {
      size += rows.size() + ProtoMessage.computeRepeatedMessageSizeNoTag(rows);
    }
    if ((bitField0_ & 0x00000002) != 0) {
      size += metadata.size() + ProtoMessage.computeRepeatedMessageSizeNoTag(metadata);
    }
    return size;
  }

  @Override
  @SuppressWarnings("fallthrough")
  public RdfStreamFrame mergeFrom(final CodedInputStream input) throws IOException {
    // Enabled Fall-Through Optimization (Quickbuf)
    int tag = input.readTag();
    while (true) {
      switch (tag) {
        case 10: {
          // rows
          initRows();
          tag = ProtoMessage.readRepeatedMessage(rows, RdfStreamRow.getFactory(), input, tag);
          bitField0_ |= 0x00000001;
          if (tag != 122) {
            break;
          }
        }
        case 122: {
          // metadata
          initMetadata();
          tag = ProtoMessage.readRepeatedMessage(metadata, MetadataEntry.getFactory(), input, tag);
          bitField0_ |= 0x00000002;
          if (tag != 0) {
            break;
          }
        }
        case 0: {
          return this;
        }
        default: {
          if (!input.skipField(tag)) {
            return this;
          }
          tag = input.readTag();
          break;
        }
      }
    }
  }

  @Override
  public RdfStreamFrame clone() {
    return new RdfStreamFrame().copyFrom(this);
  }

  @Override
  public boolean isEmpty() {
    return ((bitField0_) == 0);
  }

  public static RdfStreamFrame parseFrom(final byte[] data) throws InvalidProtocolBufferException {
    return ProtoMessage.mergeFrom(new RdfStreamFrame(), data).checkInitialized();
  }

  public static RdfStreamFrame parseFrom(final CodedInputStream input) throws IOException {
    return ProtoMessage.mergeFrom(new RdfStreamFrame(), input).checkInitialized();
  }

  /**
   * @return factory for creating RdfStreamFrame messages
   */
  public static MessageFactory<RdfStreamFrame> getFactory() {
    return RdfStreamFrameFactory.INSTANCE;
  }

  /**
   * Protobuf type {@code MetadataEntry}
   */
  public static final class MetadataEntry extends ProtoMessage<MetadataEntry> implements Cloneable {
    /**
     * <code>optional string key = 1;</code>
     */
    private String key = null;

    /**
     * <code>optional bytes value = 2;</code>
     */
    private ByteString value_ = null;

    private MetadataEntry() {
    }

    /**
     * @return a new empty instance of {@code MetadataEntry}
     */
    public static MetadataEntry newInstance() {
      return new MetadataEntry();
    }

    private void initKey() {
      if (key == null) {
        key = "";
      }
    }

    /**
     * <code>optional string key = 1;</code>
     * @return this
     */
    public MetadataEntry clearKey() {
      if (key != null) {
        key = "";
      }
      return this;
    }

    /**
     * <code>optional string key = 1;</code>
     * @return the key
     */
    public String getKey() {
      initKey();
      return key;
    }

    /**
     * <code>optional string key = 1;</code>
     * @param value the key to set
     * @return this
     */
    public MetadataEntry setKey(final String value) {
      key = value;
      return this;
    }

    private void initValue() {
      if (value_ == null) {
        value_ = ByteString.EMPTY;
      }
    }

    /**
     * <code>optional bytes value = 2;</code>
     * @return this
     */
    public MetadataEntry clearValue() {
      if (value_ != null) {
        value_ = ByteString.EMPTY;
      }
      return this;
    }

    /**
     * <code>optional bytes value = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableValue()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public ByteString getValue() {
      initValue();
      return value_;
    }

    /**
     * <code>optional bytes value = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public ByteString getMutableValue() {
      initValue();
      bitField0_ |= 0x00000002;
      return value_;
    }

    /**
     * <code>optional bytes value = 2;</code>
     * @param values the value_ to set
     * @return this
     */
    public MetadataEntry setValue(final ByteString values) {
      value_ = values;
      return this;
    }

    @Override
    public MetadataEntry copyFrom(final MetadataEntry other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        key = other.key;
        value_ = other.value_;
      }
      return this;
    }

    @Override
    public MetadataEntry mergeFrom(final MetadataEntry other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      key = other.key;
      value_ = other.value_;
      return this;
    }

    @Override
    public MetadataEntry clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      if (key != null) {
        key = "";
      }
      if (value_ != null) {
        value_ = ByteString.EMPTY;
      }
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof MetadataEntry)) {
        return false;
      }
      MetadataEntry other = (MetadataEntry) o;
      return bitField0_ == other.bitField0_
        && key.equals(other.key)
        && value_.equals(other.value_);
    }

    @Override
    public void writeTo(final CodedOutputStream output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 10);
        output.writeStringNoTag(key);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 18);
        output.writeBytesNoTag(value_);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + CodedOutputStream.computeStringSizeNoTag(key);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + CodedOutputStream.computeBytesSizeNoTag(value_);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public MetadataEntry mergeFrom(final CodedInputStream input) throws IOException {
      // Enabled Fall-Through Optimization (Quickbuf)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 10: {
            // key
            initKey();
            key = input.readStringRequireUtf8();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // value_
            initValue();
            value_ = input.readBytes();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public MetadataEntry clone() {
      return new MetadataEntry().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static MetadataEntry parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new MetadataEntry(), data).checkInitialized();
    }

    public static MetadataEntry parseFrom(final CodedInputStream input) throws IOException {
      return ProtoMessage.mergeFrom(new MetadataEntry(), input).checkInitialized();
    }

    /**
     * @return factory for creating MetadataEntry messages
     */
    public static MessageFactory<MetadataEntry> getFactory() {
      return MetadataEntryFactory.INSTANCE;
    }

    private enum MetadataEntryFactory implements MessageFactory<MetadataEntry> {
      INSTANCE;

      @Override
      public MetadataEntry create() {
        return MetadataEntry.newInstance();
      }
    }
  }

  private enum RdfStreamFrameFactory implements MessageFactory<RdfStreamFrame> {
    INSTANCE;

    @Override
    public RdfStreamFrame create() {
      return RdfStreamFrame.newInstance();
    }
  }
}
